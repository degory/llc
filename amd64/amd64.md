// copyright (C) 2009 degs <junk@giantblob.com> all rights reserved
start inst
terminal ERROR_0 = 0
terminal INDIRECT_1 = 9
terminal INDIRECT_4 = 10
terminal INDIRECT_8 = 11
terminal LEA_1 = 17
terminal LEA_4 = 18
terminal LEA_8 = 19
terminal ADD_1 = 25
terminal ADD_4 = 26
terminal ADD_8 = 27
terminal ADD2_1 = 29
terminal ADD2_4 = 30
terminal ADD2_8 = 31
terminal SUB_1 = 33
terminal SUB_4 = 34
terminal SUB_8 = 35
terminal SUB2_1 = 37
terminal SUB2_4 = 38
terminal SUB2_8 = 39
terminal SUBR_1 = 41
terminal SUBR_4 = 42
terminal SUBR_8 = 43
terminal SUBR2_1 = 45
terminal SUBR2_4 = 46
terminal SUBR2_8 = 47
terminal MUL_1 = 49
terminal MUL_4 = 50
terminal MUL_8 = 51
terminal MUL2_1 = 53
terminal MUL2_4 = 54
terminal MUL2_8 = 55
terminal DIV_1 = 57
terminal DIV_4 = 58
terminal DIV_8 = 59
terminal DIV2_1 = 61
terminal DIV2_4 = 62
terminal DIV2_8 = 63
terminal DIVR_1 = 65
terminal DIVR_4 = 66
terminal DIVR_8 = 67
terminal DIVR2_1 = 69
terminal DIVR2_4 = 70
terminal DIVR2_8 = 71
terminal MOD_1 = 73
terminal MOD_4 = 74
terminal MOD_8 = 75
terminal MOD2_1 = 77
terminal MOD2_4 = 78
terminal MOD2_8 = 79
terminal SHL_1 = 81
terminal SHL_4 = 82
terminal SHL_8 = 83
terminal SHL2_1 = 85
terminal SHL2_4 = 86
terminal SHL2_8 = 87
terminal SHAR_1 = 89
terminal SHAR_4 = 90
terminal SHAR_8 = 91
terminal SHAR2_1 = 93
terminal SHAR2_4 = 94
terminal SHAR2_8 = 95
terminal EQ_1 = 97
terminal EQ_4 = 98
terminal EQ_8 = 99
terminal EQ2_1 = 101
terminal EQ2_4 = 102
terminal EQ2_8 = 103
terminal NE_1 = 105
terminal NE_4 = 106
terminal NE_8 = 107
terminal NE2_1 = 109
terminal NE2_4 = 110
terminal NE2_8 = 111
terminal GT_1 = 113
terminal GT_4 = 114
terminal GT_8 = 115
terminal GT2_1 = 117
terminal GT2_4 = 118
terminal GT2_8 = 119
terminal LT_1 = 121
terminal LT_4 = 122
terminal LT_8 = 123
terminal LT2_1 = 125
terminal LT2_4 = 126
terminal LT2_8 = 127
terminal GE_1 = 129
terminal GE_4 = 130
terminal GE_8 = 131
terminal GE2_1 = 133
terminal GE2_4 = 134
terminal GE2_8 = 135
terminal LE_1 = 137
terminal LE_4 = 138
terminal LE_8 = 139
terminal LE2_1 = 141
terminal LE2_4 = 142
terminal LE2_8 = 143
terminal GTU_1 = 145
terminal GTU_4 = 146
terminal GTU_8 = 147
terminal GTU2_1 = 149
terminal GTU2_4 = 150
terminal GTU2_8 = 151
terminal LTU_1 = 153
terminal LTU_4 = 154
terminal LTU_8 = 155
terminal LTU2_1 = 157
terminal LTU2_4 = 158
terminal LTU2_8 = 159
terminal GEU_1 = 161
terminal GEU_4 = 162
terminal GEU_8 = 163
terminal GEU2_1 = 165
terminal GEU2_4 = 166
terminal GEU2_8 = 167
terminal LEU_1 = 169
terminal LEU_4 = 170
terminal LEU_8 = 171
terminal LEU2_1 = 173
terminal LEU2_4 = 174
terminal LEU2_8 = 175
terminal AND_1 = 177
terminal AND_4 = 178
terminal AND_8 = 179
terminal AND2_1 = 181
terminal AND2_4 = 182
terminal AND2_8 = 183
terminal OR_1 = 185
terminal OR_4 = 186
terminal OR_8 = 187
terminal OR2_1 = 189
terminal OR2_4 = 190
terminal OR2_8 = 191
terminal XOR_1 = 193
terminal XOR_4 = 194
terminal XOR_8 = 195
terminal XOR2_1 = 197
terminal XOR2_4 = 198
terminal XOR2_8 = 199
terminal NOT_1 = 201
terminal NOT_4 = 202
terminal NOT_8 = 203
terminal NOT2_1 = 205
terminal NOT2_4 = 206
terminal NOT2_8 = 207
terminal NEG_1 = 209
terminal NEG_4 = 210
terminal NEG_8 = 211
terminal NEG2_1 = 213
terminal NEG2_4 = 214
terminal NEG2_8 = 215
terminal ELIGIBLE_CSE_1 = 217
terminal ELIGIBLE_CSE_4 = 218
terminal ELIGIBLE_CSE_8 = 219
terminal CSE_1 = 225
terminal CSE_4 = 226
terminal CSE_8 = 227
terminal NOP_0 = 232
terminal COMMENT_0 = 240
terminal DUMMY_0 = 248
terminal OBJ_EQ_0 = 256
terminal OBJ_EQ2_0 = 260
terminal OBJ_NE_0 = 264
terminal OBJ_NE2_0 = 268
terminal BOUNDS_L_0 = 272
terminal BOUNDS_0 = 280
terminal BOUNDS_R_0 = 288
terminal LOCAL_1 = 297
terminal LOCAL_4 = 298
terminal LOCAL_8 = 299
terminal RLOCAL_1 = 305
terminal RLOCAL_4 = 306
terminal RLOCAL_8 = 307
terminal INSTANCE_1 = 313
terminal INSTANCE_4 = 314
terminal INSTANCE_8 = 315
terminal EXTERN_0 = 320
terminal GLOBAL_1 = 329
terminal GLOBAL_4 = 330
terminal GLOBAL_8 = 331
terminal LABEL_0 = 336
terminal DLABEL_0 = 344
terminal CAST_FROM1_4 = 354
terminal CAST_FROM1_8 = 355
terminal CAST_FROM11_4 = 358
terminal CAST_FROM11_8 = 359
terminal CAST_FROM4_1 = 361
terminal CAST_FROM4_4 = 362
terminal CAST_FROM4_8 = 363
terminal CAST_FROM41_1 = 365
terminal CAST_FROM41_4 = 366
terminal CAST_FROM41_8 = 367
terminal CAST_FROM8_1 = 369
terminal CAST_FROM8_4 = 370
terminal CAST_FROM81_1 = 373
terminal CAST_FROM81_4 = 374
terminal TREAT_AS_1 = 377
terminal TREAT_AS_4 = 378
terminal TREAT_AS_8 = 379
terminal TREAT_AS1_1 = 381
terminal TREAT_AS1_4 = 382
terminal TREAT_AS1_8 = 383
terminal CAST_CHECK_0 = 384
terminal CAST_CHECK1_0 = 388
terminal THIS_0 = 392
terminal FRAME_0 = 400
terminal CONST_1 = 409
terminal CONST_4 = 410
terminal CONST_8 = 411
terminal CONST_STR_0 = 416
terminal CONST_CSTR_0 = 424
terminal BOX_0 = 432
terminal BOOL_OR_1 = 441
terminal BOOL_OR_4 = 442
terminal BOOL_OR_8 = 443
terminal BOOL_AND_1 = 449
terminal BOOL_AND_4 = 450
terminal BOOL_AND_8 = 451
terminal BOOL_NOT_1 = 457
terminal BOOL_NOT_4 = 458
terminal BOOL_NOT_8 = 459
terminal STORE_THIS_0 = 464
terminal SAVE_THIS_0 = 472
terminal RESTORE_THIS_0 = 480
terminal CALL_0 = 488
terminal STATIC_CALL_0 = 496
terminal DYNAMIC_CALL_0 = 504
terminal STATIC_DYNAMIC_CALL_0 = 512
terminal STATIC_CALL_DISCARD_0 = 520
terminal DYNAMIC_CALL_DISCARD_0 = 528
terminal STATIC_DYNAMIC_CALL_DISCARD_0 = 536
terminal PROC_CALL_0 = 544
terminal PROC_CALL_DISCARD_0 = 552
terminal PROC_REF_0 = 560
terminal NEW_0 = 568
terminal NEW_FINALIZE_0 = 576
terminal NEW_ARRAY_0 = 584
terminal NEW_OBJ_ARRAY_0 = 592
terminal NEW_GENERIC_ARRAY_0 = 600
terminal PAIR_1 = 609
terminal PAIR_4 = 610
terminal PAIR_8 = 611
terminal PUSH_1 = 617
terminal PUSH_4 = 618
terminal PUSH_8 = 619
terminal POP_1 = 625
terminal POP_4 = 626
terminal POP_8 = 627
terminal RET_0 = 632
terminal STORE_1 = 641
terminal STORE_4 = 642
terminal STORE_8 = 643
terminal THROW_1 = 649
terminal THROW_4 = 650
terminal THROW_8 = 651
terminal TRY_0 = 656
terminal START_CATCH_0 = 664
terminal CATCH_0 = 672
terminal SUSPEND_CATCH_0 = 680
terminal END_FINALLY_0 = 688
terminal END_CATCH_0 = 696
terminal END_TRY_0 = 704
terminal COND_RETHROW_0 = 712
terminal COND_RETURN_0 = 720
terminal THROW_RETURN_1 = 729
terminal THROW_RETURN_4 = 730
terminal THROW_RETURN_8 = 731
terminal RETURN_RETHROW_0 = 736
terminal ADJUST_0 = 744
terminal PUSH_EBP_0 = 752
terminal SAVE_ALL_0 = 760
terminal RESTORE_ALL_0 = 768
terminal JUMP_0 = 776
terminal DUMMY_JUMP_0 = 784
terminal CMP_1 = 793
terminal CMP_4 = 794
terminal CMP_8 = 795
terminal CMP2_1 = 797
terminal CMP2_4 = 798
terminal CMP2_8 = 799
terminal DECBNN_1 = 801
terminal DECBNN_4 = 802
terminal DECBNN_8 = 803
terminal DECBNN1_1 = 805
terminal DECBNN1_4 = 806
terminal DECBNN1_8 = 807
terminal BRANCH_0 = 808
terminal BRANCH1_0 = 812
terminal BRANCHZ_1 = 817
terminal BRANCHZ_4 = 818
terminal BRANCHZ_8 = 819
terminal BRANCHZ1_1 = 821
terminal BRANCHZ1_4 = 822
terminal BRANCHZ1_8 = 823
terminal BRANCHNZ_1 = 825
terminal BRANCHNZ_4 = 826
terminal BRANCHNZ_8 = 827
terminal BRANCHNZ1_1 = 829
terminal BRANCHNZ1_4 = 830
terminal BRANCHNZ1_8 = 831
terminal JE_0 = 832
terminal JNE_0 = 840
terminal JG_0 = 848
terminal JL_0 = 856
terminal JGE_0 = 864
terminal JLE_0 = 872
terminal JGU_0 = 880
terminal JLU_0 = 888
terminal JGEU_0 = 896
terminal JLEU_0 = 904
terminal SETE_1 = 913
terminal SETNE_1 = 921
terminal SETG_1 = 929
terminal SETL_1 = 937
terminal SETGE_1 = 945
terminal SETLE_1 = 953
terminal SETGU_1 = 961
terminal SETLU_1 = 969
terminal SETGEU_1 = 977
terminal SETLEU_1 = 985
terminal RESERVE_0 = 992
terminal RELEASE_0 = 1000
terminal ENTER_0 = 1008
terminal LEAVE_0 = 1016
terminal RESULT_1 = 1025
terminal RESULT_4 = 1026
terminal RESULT_8 = 1027
terminal RESULT_F_0 = 1032
terminal ENTER_LOOP_0 = 1040
terminal LEAVE_LOOP_0 = 1048
terminal LINE_0 = 1056
terminal REG_VAR_1 = 1065
terminal REG_VAR_4 = 1066
terminal REG_VAR_8 = 1067
terminal REGISTER_1 = 1073
terminal REGISTER_4 = 1074
terminal REGISTER_8 = 1075
terminal TEMP_1 = 1081
terminal TEMP_4 = 1082
terminal TEMP_8 = 1083
terminal MEMORY_1 = 1089
terminal MEMORY_4 = 1090
terminal MEMORY_8 = 1091
terminal PARAM0_1 = 1097
terminal PARAM0_4 = 1098
terminal PARAM0_8 = 1099
terminal PARAM1_1 = 1105
terminal PARAM1_4 = 1106
terminal PARAM1_8 = 1107
terminal PARAM2_1 = 1113
terminal PARAM2_4 = 1114
terminal PARAM2_8 = 1115
terminal PARAM3_1 = 1121
terminal PARAM3_4 = 1122
terminal PARAM3_8 = 1123
terminal PARAM4_1 = 1129
terminal PARAM4_4 = 1130
terminal PARAM4_8 = 1131
terminal PARAM5_1 = 1137
terminal PARAM5_4 = 1138
terminal PARAM5_8 = 1139
terminal ARG0_1 = 1145
terminal ARG0_4 = 1146
terminal ARG0_8 = 1147
terminal ARG1_1 = 1153
terminal ARG1_4 = 1154
terminal ARG1_8 = 1155
terminal ARG2_1 = 1161
terminal ARG2_4 = 1162
terminal ARG2_8 = 1163
terminal ARG3_1 = 1169
terminal ARG3_4 = 1170
terminal ARG3_8 = 1171
terminal ARG4_1 = 1177
terminal ARG4_4 = 1178
terminal ARG4_8 = 1179
terminal ARG5_1 = 1185
terminal ARG5_4 = 1186
terminal ARG5_8 = 1187
terminal INIT_REG_VAR_0 = 1192
terminal SAVE_REG_VAR_0 = 1200
terminal RESTORE_REG_VAR_0 = 1208
terminal SEQ_1 = 1217
terminal SEQ_4 = 1218
terminal SEQ_8 = 1219
terminal LIST_0 = 1224
terminal COPY_1 = 1233
terminal COPY_4 = 1234
terminal COPY_8 = 1235
terminal STATIC_0 = 1240
terminal TEXT_0 = 1248
terminal DATA_0 = 1256
terminal RODATA_0 = 1264
terminal UNWIND_0 = 1272
terminal PUSHSEG_0 = 1280
terminal POPSEG_0 = 1288
terminal RELOC_0 = 1296
terminal DEFINT_1 = 1305
terminal DEFINT_4 = 1306
terminal DEFINT_8 = 1307


rule inst = [COMMENT] 0 [Inst [Data COMMENT [Const $A.S]]]

rewrite inst = [LIST inst inst] 0 [LIST $0 $1]



rewrite t = [ADD_8 t tvmi] 10 [SEQ [ADD2 $0 $1] $0.T ]
rewrite t = [ADD_8 tvmi t] 10 [SEQ [ADD2 $1 $0] $1.T ]	
rewrite t = [SUB_8 t tvmi] 10 [SEQ [SUB2 $0 $1] $0.T ]	
rewrite t = [MUL_8 t tvmi] 10 [SEQ [MUL2 $0 $1] $0.T ]
rewrite t = [MUL_8 tvmi t] 10 [SEQ [MUL2 $1 $0] $1.T ]
rewrite t = [MUL_8 tvm immed] 10 [SEQ [COPY $T [MUL $0 $1]] $T ]
rewrite t = [MUL_8 immed tvm] 10 [SEQ [COPY $T [MUL $1 $0]] $T ]
rewrite t = [DIV_8 t tvm] 10 [SEQ [DIV [PAIR $0 $1] $T] $0.T]
rewrite t = [MOD_8 t tvm] 10 [SEQ [MOD [PAIR $T $0] $1] $T]
rewrite t = [AND_8 t tvmi] 10 [SEQ [AND2 $0 $1] $0.T ]
rewrite t = [AND_8 tvmi t] 10 [SEQ [AND2 $1 $0] $1.T ]
rewrite t = [OR_8 t tvmi] 10 [SEQ [OR2 $0 $1] $0.T ]
rewrite t = [OR_8 tvmi t] 10 [SEQ [OR2 $1 $0] $1.T ]
rewrite t = [XOR_8 t tvmi] 10 [SEQ [XOR2 $0 $1] $0.T ]
rewrite t = [XOR_8 tvmi t] 10 [SEQ [XOR2 $1 $0] $1.T ]
rewrite t = [SHL_8 t tv] 10 [SEQ [SHL2 $0 $1] $0.T ]
rewrite t = [SHAR_8 t tv] 10 [SEQ [SHAR2 $0 $1] $0.T ]
rewrite t = [NEG_8 t] 10 [SEQ [NEG2 $0] $0.T ]
rewrite t = [NOT_8 t] 10 [SEQ [NOT2 $0] $0.T ]


rewrite t = [ADD_4 t tvmi] 10 [SEQ-4 [ADD2 $0 $1] $0.T ]	
rewrite t = [ADD_4 tvmi t] 10 [SEQ-4 [ADD2 $1 $0] $1.T ]	
rewrite t = [SUB_4 t tvmi] 10 [SEQ-4 [SUB2 $0 $1] $0.T ]	
rewrite t = [MUL_4 t tvmi] 10 [SEQ-4 [MUL2 $0 $1] $0.T ]
rewrite t = [MUL_4 tvmi t] 10 [SEQ-4 [MUL2 $1 $0] $1.T ]
rewrite t = [MUL_4 tvm immed] 10 [SEQ-4 [COPY $T [MUL $0 $1]] $T ]
rewrite t = [MUL_4 immed tvm] 10 [SEQ-4 [COPY $T [MUL $1 $0]] $T ]
rewrite t = [DIV_4 t tvm] 10 [SEQ-4 [DIV [PAIR $0 $1] $T] $0.T]
// rewrite t = [DIV_4 tvm t] 10 [SEQ [DIVR [PAIR $1 $0] $T] $1.T]
rewrite t = [MOD_4 t tvm] 10 [SEQ [MOD [PAIR $T $0] $1] $T]
rewrite t = [AND_4 t tvmi] 10 [SEQ-4 [AND2 $0 $1] $0.T ]
rewrite t = [AND_4 tvmi t] 10 [SEQ-4 [AND2 $1 $0] $1.T ]
rewrite t = [OR_4 t tvmi] 10 [SEQ-4 [OR2 $0 $1] $0.T ]
rewrite t = [OR_4 tvmi t] 10 [SEQ-4 [OR2 $1 $0] $1.T ]
rewrite t = [XOR_4 t tvmi] 10 [SEQ-4 [XOR2 $0 $1] $0.T ]
rewrite t = [XOR_4 tvmi t] 10 [SEQ-4 [XOR2 $1 $0] $1.T ]
rewrite t = [SHL_4 t tv] 10 [SEQ-4 [SHL2 $0 $1] $0.T ]
rewrite t = [SHAR_4 t tv] 10 [SEQ-4 [SHAR2 $0 $1] $0.T ]
rewrite t = [NEG_4 t] 10 [SEQ-4 [NEG2 $0] $0.T ]
rewrite t = [NOT_4 t] 10 [SEQ-4 [NOT2 $0] $0.T ]


rewrite t = [ADD_1 t tvmi] 10 [SEQ-1 [ADD2 $0 $1] $0.T ]	
rewrite t = [ADD_1 tvmi t] 10 [SEQ-1 [ADD2 $1 $0] $1.T ]	
rewrite t = [SUB_1 t tvmi] 10 [SEQ-1 [SUB2 $0 $1] $0.T ]	
rewrite t = [MUL_1 t tvmi] 10 [SEQ-1 [MUL2 $0 $1] $0.T ]
rewrite t = [MUL_1 tvmi t] 10 [SEQ-1 [MUL2 $1 $0] $0.T ]
rewrite t = [MUL_1 tvm immed] 10 [SEQ-1 [COPY $T [MUL $0 $1]] $T ]
rewrite t = [MUL_1 immed tvm] 10 [SEQ-1 [COPY $T [MUL $1 $0]] $T ]
rewrite t = [DIV_1 t tvm] 10 [SEQ-1 [DIV [PAIR $0 $1] $T] $0.T]
// rewrite t = [DIV_1 tvm t] 10 [SEQ [DIVR [PAIR $1 $0] $T] $1.T]
rewrite t = [MOD_1 t tvm] 10 [SEQ [MOD [PAIR $T $0] $1] $T]
rewrite t = [AND_1 t tvmi] 10 [SEQ-1 [AND2 $0 $1] $0.T ]
rewrite t = [AND_1 tvmi t] 10 [SEQ-1 [AND2 $1 $0] $1.T ]
rewrite t = [OR_1 t tvmi] 10 [SEQ-1 [OR2 $0 $1] $0.T ]
rewrite t = [OR_1 tvmi t] 10 [SEQ-1 [OR2 $1 $0] $1.T ]
rewrite t = [XOR_1 t tvmi] 10 [SEQ-1 [XOR2 $0 $1] $0.T ]
rewrite t = [XOR_1 tvmi t] 10 [SEQ-1 [XOR2 $1 $0] $1.T ]
rewrite t = [SHL_1 t tv] 10 [SEQ-1 [SHL2 $0 $1] $0.T ]
rewrite t = [SHAR_1 t tv] 10 [SEQ-1 [SHAR2 $0 $1] $0.T ]
rewrite t = [NEG_1 t] 10 [SEQ-1 [NEG2 $0] $0.T ]
rewrite t = [NOT_1 t] 10 [SEQ-1 [NOT2 $0] $0.T ]



// don't know what size the operand is here but want to rewrite to a SEQ+TEMP of the same size:
rewrite t = tvmi 5 {            int size = children[0].getSize(); int temp_t = Gen.TempFactory.nextTemp(); return new ITree(0,Op.SEQ,size,new ITree(0,Op.COPY,size,new ITree(0,Op.TEMP,size,temp_t),(children[0])),new ITree(0,Op.TEMP,size,temp_t)); }

// rewrite t = tvmi 10 	[SEQ [COPY $T $0] $T]
rewrite t = addr 10 	[SEQ [LEA $T $0] $T]

rewrite inst = [LEA_8 tv addr] 10 [LEA $0 $1]

rewrite immed = [CAST_FROM4_4 immed] 0 "$0"
rewrite tv = [CAST_FROM4_4 tv] 0 "$0"
rewrite mem = [CAST_FROM4_4 mem] 0 "$0"

rewrite immed = [CAST_FROM1_8 immed] 0 "$0"
rewrite tv = [CAST_FROM1_8 tvm] 10 [SEQ [CAST_FROM1 $T $0] $T]
// rewrite tv = [CAST_FROM1_8 t] 10 [SEQ [CAST_FROM1 $0.T] $0.T] 

rewrite immed = [CAST_FROM1_4 immed] 0 "$0"
rewrite tv = [CAST_FROM1_4 tvm] 10 [SEQ [CAST_FROM1 $T $0] $T]
// rewrite tv = [CAST_FROM1_4 t] 10 [SEQ [CAST_FROM1 $0.T] $0.T]

rewrite immed = [CAST_FROM4_8 immed] 0 "$0"
// rewrite tv = [CAST_FROM4_8 tvm] 10 [SEQ [TREAT_AS8 $0] $T]
rewrite tv = [CAST_FROM4_8 tvm] 10 [SEQ [CAST_FROM4 $T $0] $T]
// rewrite tv = [CAST_FROM4_8 t] 10 [SEQ [CAST_FROM4 $0.T] $0.T]

//rewrite immed = [CAST_FROM4_8 immed] 0 "$0"
//rewrite mem = [CAST_FROM4_8 mem] 0 "$0"
//rewrite t = [CAST_FROM4_8 t] 0 [SEQ [TREAT_AS_8 $0] $0.T]

rewrite immed = [CAST_FROM4_1 immed] 0 "$0"
rewrite mem = [CAST_FROM4_1 mem] 0 "$0"
rewrite t = [CAST_FROM4_1 t] 0 [SEQ [TREAT_AS_1 $0] $0.T]

rewrite immed = [CAST_FROM8_4 immed] 0 "$0"
rewrite mem = [CAST_FROM8_4 mem] 0 "$0"
rewrite t = [CAST_FROM8_4 t] 0 [SEQ [TREAT_AS_8 $0] $0.T]

rewrite immed = [CAST_FROM8_1 immed] 0 "$0"
rewrite mem = [CAST_FROM8_1 mem] 0 "$0"
rewrite t = [CAST_FROM8_1 t] 0 [SEQ [TREAT_AS_1 $0] $0.T]

rewrite tvm = [TREAT_AS_8 tvm] 0 "$0"
rewrite tvm = [TREAT_AS_4 tvm] 0 "$0"
rewrite tvm = [TREAT_AS_1 tvm] 0 "$0"

rewrite tv = [CAST_CHECK tv tvi] 10
    [SEQ
	[LIST
	    [COPY $T $0]
	    [*BRANCHZ $T $M]
	    [LABEL $L]
	    [*BRANCH [EQ [INDIRECT [ADD [CONST 0] $T]] $1] $M]
	    [COPY $T [INDIRECT [ADD [CONST 0] $T]]]
	    [*BRANCHNZ $T $L]
            [CALL "__throw_castexception"]
	    [LABEL $M]
	]
	$0.T
    ]


rewrite inst = [OBJ_EQ_0 [PAIR_8 tv tv] tv] 20 
    [LIST
	// FIXME: must be a way to do this without all these jumps?
	[COPY_8 $T [CMP_8 $0 $1]]
        [COPY_1 $2 [CONST 1]]
	[JE $T $A.S]
	[COPY_8 $U [CMP_8 $0 [CONST 0]]]
        [COPY_1 $2 [CONST 0]]
	[JE $U $A.S]
	[COPY_8 $U [CMP_8 $1 [CONST 0]]]
	[JE $U $A.S]
    ]

rewrite inst = [OBJ_NE_0 [PAIR_8 tv tv] tv] 20 
    [LIST
	// FIXME: must be a way to do this without all these jumps?
	[COPY_8 $T [CMP_8 $0 $1]]
        [COPY_1 $2 [CONST 0]]
	[JE $T $A.S]
	[COPY_8 $U [CMP_8 $0 [CONST 0]]]
        [COPY_1 $2 [CONST 1]]
	[JE $U $A.S]
	[COPY_8 $U [CMP_8 $1 [CONST 0]]]
	[JE $U $A.S]
    ]

rewrite inst = [COPY_8 tvm tvi] 5 [COPY_8 $0 $1]
rewrite inst = [COPY_4 tvm tvi] 5 [COPY_4 $0 $1]
rewrite inst = [COPY_1 tvm tvi] 5 [COPY_1 $0 $1]
rewrite inst = [COPY_8 tv mem] 10 [COPY_8 $0 $1]
rewrite inst = [COPY_4 tv mem] 10 [COPY_4 $0 $1]
rewrite inst = [COPY_1 tv mem] 10 [COPY_1 $0 $1]

rewrite inst = [PUSH_8 tvmi] 10 [PUSH_8 $0]
rewrite inst = [POP_8 tvm] 10 [POP_8 $0]

rewrite inst = [COPY_8 tvm [ADD_8 tvm tvi]] { a.mem2mem(10,32768) } [ADD2 $1 $2]
rewrite inst = [COPY_8 tvm [ADD_8 tvi tvm]] { a.mem2memR(10,32768) } [ADD2 $2 $1]
rewrite inst = [COPY_8 tvm [AND_8 tvm tvi]] { a.mem2mem(10,32768) } [AND2 $1 $2]
rewrite inst = [COPY_8 tvm [AND_8 tvi tvm]] { a.mem2memR(10,32768) } [AND2 $2 $1]
rewrite inst = [COPY_8 tvm [OR_8 tvm tvi]] { a.mem2mem(10,32768) } [OR2 $1 $2]
rewrite inst = [COPY_8 tvm [OR_8 tvi tvm]] { a.mem2memR(10,32768) } [OR2 $2 $1]
rewrite inst = [COPY_8 tvm [SUB_8 tvm tvi]] { a.mem2mem(10,32768) } [SUB2 $1 $2]
rewrite inst = [COPY_8 tvm [SUB_8 tvi tvm]] { a.mem2memR(10,32768) } [SUBR2 $2 $1]
rewrite inst = [COPY_8 tv [MUL_8 tv tvmi]] { a.mem2mem(10,32768) } [MUL2 $1 $2]
rewrite inst = [COPY_8 tv [MUL_8 tvmi tv]] { a.mem2memR(10,32768) } [MUL2 $2 $1]

rewrite inst = [COPY_4 tvm [ADD_4 tvm tvi]] { a.mem2mem(10,32768) } [ADD2-4 $1 $2]
rewrite inst = [COPY_4 tvm [ADD_4 tvi tvm]] { a.mem2memR(10,32768) } [ADD2-4 $2 $1]
rewrite inst = [COPY_4 tvm [AND_4 tvm tvi]] { a.mem2mem(10,32768) } [AND2-4 $1 $2]
rewrite inst = [COPY_4 tvm [AND_4 tvi tvm]] { a.mem2memR(10,32768) } [AND2-4 $2 $1]
rewrite inst = [COPY_4 tvm [OR_4 tvm tvi]] { a.mem2mem(10,32768) } [OR2-4 $1 $2]
rewrite inst = [COPY_4 tvm [OR_4 tvi tvm]] { a.mem2memR(10,32768) } [OR2-4 $2 $1]
rewrite inst = [COPY_4 tvm [SUB_4 tvm tvi]] { a.mem2mem(10,32768) } [SUB2-4 $1 $2]
rewrite inst = [COPY_4 tvm [SUB_4 tvi tvm]] { a.mem2memR(10,32768) } [SUBR2-4 $2 $1]
rewrite inst = [COPY_4 tv [MUL_4 tv tvmi]] { a.mem2mem(10,32768) } [MUL2-4 $1 $2]
rewrite inst = [COPY_4 tv [MUL_4 tvmi tv]] { a.mem2memR(10,32768) } [MUL2-4 $2 $1]

rewrite inst = [COPY_1 tvm [ADD_1 tvm tvi]] { a.mem2mem(10,32768) } [ADD2-1 $1 $2]
rewrite inst = [COPY_1 tvm [ADD_1 tvi tvm]] { a.mem2memR(10,32768) } [ADD2-1 $2 $1]
rewrite inst = [COPY_1 tvm [AND_1 tvm tvi]] { a.mem2mem(10,32768) } [AND2-1 $1 $2]
rewrite inst = [COPY_1 tvm [AND_1 tvi tvm]] { a.mem2memR(10,32768) } [AND2-1 $2 $1]
rewrite inst = [COPY_1 tvm [OR_1 tvm tvi]] { a.mem2mem(10,32768) } [OR2-1 $1 $2]
rewrite inst = [COPY_1 tvm [OR_1 tvi tvm]] { a.mem2memR(10,32768) } [OR2-1 $2 $1]
rewrite inst = [COPY_1 tvm [SUB_1 tvm tvi]] { a.mem2mem(10,32768) } [SUB2-1 $1 $2]
rewrite inst = [COPY_1 tvm [SUB_1 tvi tvm]] { a.mem2memR(10,32768) } [SUBR2-1 $2 $1]
rewrite inst = [COPY_1 tv [MUL_1 tv tvmi]] { a.mem2mem(10,32768) } [MUL2-1 $1 $2]
rewrite inst = [COPY_1 tv [MUL_1 tvmi tv]] { a.mem2memR(10,32768) } [MUL2-1 $2 $1]

rewrite compare = [EQ_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JE]] $T]
rewrite compare = [EQ_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JE]] $T]
rewrite compare = [NE_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JNE]] $T]
rewrite compare = [NE_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JNE]] $T]
rewrite compare = [GT_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JG]] $T]
rewrite compare = [GT_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JL]] $T]
rewrite compare = [LT_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JL]] $T]
rewrite compare = [LT_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JG]] $T]
rewrite compare = [GE_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JGE]] $T]
rewrite compare = [GE_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JLE]] $T]
rewrite compare = [LE_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JLE]] $T]
rewrite compare = [LE_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JGE]] $T]
rewrite compare = [GTU_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JGU]] $T]
rewrite compare = [GTU_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JLU]] $T]
rewrite compare = [LTU_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JLU]] $T]
rewrite compare = [LTU_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JGU]] $T]
rewrite compare = [GEU_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JGEU]] $T]
rewrite compare = [GEU_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JLEU]] $T]
rewrite compare = [LEU_8 tvm tvi] 20 [SEQ [COPY $T [CMP $0 $1 JLEU]] $T]
rewrite compare = [LEU_8 tvi tvm] 20 [SEQ [COPY $T [CMP $1 $0 JGEU]] $T]

rewrite compare = [EQ_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JE]] $T]
rewrite compare = [EQ_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JE]] $T]
rewrite compare = [NE_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JNE]] $T]
rewrite compare = [NE_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JNE]] $T]
rewrite compare = [GT_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JG]] $T]
rewrite compare = [GT_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JL]] $T]
rewrite compare = [LT_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JL]] $T]
rewrite compare = [LT_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JG]] $T]
rewrite compare = [GE_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JGE]] $T]
rewrite compare = [GE_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JLE]] $T]
rewrite compare = [LE_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JLE]] $T]
rewrite compare = [LE_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JGE]] $T]
rewrite compare = [GTU_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JGU]] $T]
rewrite compare = [GTU_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JLU]] $T]
rewrite compare = [LTU_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JLU]] $T]
rewrite compare = [LTU_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JGU]] $T]
rewrite compare = [GEU_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JGEU]] $T]
rewrite compare = [GEU_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JLEU]] $T]
rewrite compare = [LEU_4 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-4 $0 $1 JLEU]] $T]
rewrite compare = [LEU_4 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-4 $1 $0 JGEU]] $T]

rewrite compare = [EQ_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JE]] $T]
rewrite compare = [EQ_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JE]] $T]
rewrite compare = [NE_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JNE]] $T]
rewrite compare = [NE_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JNE]] $T]
rewrite compare = [GT_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JG]] $T]
rewrite compare = [GT_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JL]] $T]
rewrite compare = [LT_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JL]] $T]
rewrite compare = [LT_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JG]] $T]
rewrite compare = [GE_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JGE]] $T]
rewrite compare = [GE_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JLE]] $T]
rewrite compare = [LE_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JLE]] $T]
rewrite compare = [LE_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JGE]] $T]
rewrite compare = [GTU_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JGU]] $T]
rewrite compare = [GTU_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JLU]] $T]
rewrite compare = [LTU_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JLU]] $T]
rewrite compare = [LTU_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JGU]] $T]
rewrite compare = [GEU_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JGEU]] $T]
rewrite compare = [GEU_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JLEU]] $T]
rewrite compare = [LEU_1 tvm tvi] 20 [SEQ-8 [COPY $T [CMP-1 $0 $1 JLEU]] $T]
rewrite compare = [LEU_1 tvi tvm] 20 [SEQ-8 [COPY $T [CMP-1 $1 $0 JGEU]] $T]

rewrite t = compare 20 [SEQ [{children[0].getLeft().getRight().getInt()-Op.JE+Op.SETE_1}-1 $T $0] $T]

rewrite inst = [DECBNN_8 tvm] 20 [DECBNN_8 $0 $A.S]
machine inst = [DECBNN_8 tm] 20 [Inst [DecBranchNotNeg DECBNN_8 $0 [Const $A.S]]]

rewrite inst = [BRANCH compare] 10 [$0.L.R.I-0 $0 $A.S] 

rewrite inst = [BRANCH immed] { a.getLeft().valueIs("0",32768,0) } [JUMP $A.S]
rewrite inst = [BRANCH immed] { a.getLeft().valueIs("0",0,32768) } [COMMENT "dead branch"]

rewrite inst = [BRANCHZ_8 immed] { a.getLeft().valueIs("0",32768,0) } [COMMENT "dead branch"]
rewrite inst = [BRANCHZ_8 immed] { a.getLeft().valueIs("0",0,32768) } [JUMP $A.S]
rewrite inst = [BRANCHNZ_8 immed] { a.getLeft().valueIs("0",32768,0) } [JUMP $A.S]
rewrite inst = [BRANCHNZ_8 immed] { a.getLeft().valueIs("0",0,32768) } [COMMENT "dead branch"]

rewrite inst = [BRANCHZ_4 immed] { a.getLeft().valueIs("0",32768,0) } [COMMENT "dead branch"]
rewrite inst = [BRANCHZ_4 immed] { a.getLeft().valueIs("0",0,32768) } [JUMP $A.S]
rewrite inst = [BRANCHNZ_4 immed] { a.getLeft().valueIs("0",32768,0) } [JUMP $A.S]
rewrite inst = [BRANCHNZ_4 immed] { a.getLeft().valueIs("0",0,32768) } [COMMENT "dead branch"]

rewrite inst = [BRANCHZ_1 immed] { a.getLeft().valueIs("0",32768,0) } [COMMENT "dead branch"]
rewrite inst = [BRANCHZ_1 immed] { a.getLeft().valueIs("0",0,32768) } [JUMP $A.S]
rewrite inst = [BRANCHNZ_1 immed] { a.getLeft().valueIs("0",32768,0) } [JUMP $A.S]
rewrite inst = [BRANCHNZ_1 immed] { a.getLeft().valueIs("0",0,32768) } [COMMENT "dead branch"]

rewrite inst = [LINE] 0 [LIST
    [DLABEL $L]
    [PUSHSEG]
    [UNWIND]
    [DEFINT $L]
    [DEFINT $A.S]
    [POPSEG]
    [LINE $A.S]
]

rewrite inst = [BRANCHZ_8 tvm] 10
    [JE
	[SEQ
	    [COPY $T [CMP_8 $0 [CONST 0]]]
	    $T
	]
	$A.S
    ]

rewrite inst = [BRANCHNZ_8 tvm] 10
    [JNE
	[SEQ
	    [COPY $T [CMP_8 $0 [CONST 0]]]
	    $T
	]
	$A.S
    ]

rewrite inst = [BRANCHZ_4 tvm] 10
    [JE
	[SEQ
	    [COPY $T [CMP-4 $0 [CONST 0]]]
	    $T
	]
	$A.S
    ]

rewrite inst = [BRANCHNZ_4 tvm] 10
    [JNE
	[SEQ
	    [COPY $T [CMP-4 $0 [CONST 0]]]
	    $T
	]
	$A.S
    ]

rewrite inst = [BRANCHZ_1 tvm] 10
    [JE
	[SEQ
	    [COPY $T [CMP-1 $0 [CONST 0]]]
	    $T
	]
	$A.S
    ]

rewrite inst = [BRANCHNZ_1 tvm] 10
    [JNE
	[SEQ
	    [COPY $T [CMP-1 $0 [CONST 0]]]
	    $T
	]
	$A.S
    ]

rewrite inst = JUMP 10 [JUMP $A.S]

// rewrite const = [RELOC_0 global const] 0 [RELOC_0 $0 $1]
// rewrite const = [RELOC_0 const global] 0 [RELOC_0 $1 $0]

// rewrite const = [ADD_8 global const] 0 [RELOC_0 $0 $1]
// rewrite const = [ADD_8 const global] 0 [RELOC_0 $1 $0]

rewrite t = [BOX t] 0 
    [SEQ
        [LIST
	    [ARG0 $0 [COMMENT "last arg"]]
	    [CALL $T "box$$integer"]
        ] 
        $T
    ]

rewrite mem = [CONST_STR] { ITree.wantPIC(0,32768) }
    [SEQ
	[LIST
	    [PUSHSEG]
	    [RODATA]
	    [DLABEL $L]
	    [CONST_CSTR $A.S]
	    [DLABEL $M]
	    [DEFINT " __ctable_N6System6StringE+24"]
	    [DEFINT $L]
	    [DEFINT {node.getString().getLength()} ]
	    [POPSEG]
	]
	[INDIRECT { new ITree(0,Op.LABEL,0,".L"+temp_m + "@GOTPCREL(%%rip)") } ]
    ]

rewrite const = [CONST_STR] { ITree.wantPIC(32768,0) }
    [SEQ
	[LIST
	    [PUSHSEG]
	    [RODATA]
	    [DLABEL $L]
	    [CONST_CSTR $A.S]
	    [DLABEL $M]
	    [DEFINT " __ctable_N6System6StringE+24"]
	    [DEFINT $L]
	    [DEFINT {node.getString().getLength()} ]
	    [POPSEG]
	]
	[GLOBAL $M]
    ]

rewrite mem = [CONST_CSTR] { ITree.wantPIC(0,32768) }
    [SEQ
	[LIST
	    [PUSHSEG]
	    [RODATA]
	    [DLABEL $L]
	    [CONST_CSTR $A.S]
	    [POPSEG]
	]
	[INDIRECT { new ITree(0,Op.LABEL,0,".L"+temp_l + "@GOTPCREL(%%rip)") } ]
    ]

rewrite const = [CONST_CSTR] { ITree.wantPIC(32768,0) }
    [SEQ
	[LIST
	    [PUSHSEG]
	    [RODATA]
	    [DLABEL $L]
	    [CONST_CSTR $A.S]
	    [POPSEG]
	]	
	[GLOBAL $L]
    ]


rewrite inst = [RESULT_8 t] 0
    [LIST
	[RESULT $0]
        [JUMP $A.S]
    ]

rewrite inst = [RESULT_F t] 0
    [LIST
	[RESULT $0]
    ]


rewrite inst = [PUSH_EBP] 10 [PUSH [REGISTER 7]]

rule inst = [PUSHSEG] 0 [Inst [Data PUSHSEG]]
rule inst = [POPSEG] 0 [Inst [Data POPSEG]]
rule inst = [STATIC] 0 [Inst [Data STATIC]]
rule inst = [TEXT] 0 [Inst [Data TEXT]]
rule inst = [DATA] 0 [Inst [Data DATA]]
rule inst = [RODATA] 0 [Inst [Data RODATA]]

//rewrite inst = [TRY tvi addr] { ITree.wantPIC(0,32768) }
//    [LIST
//        [COPY $T [INDIRECT $1]] // GLOBAL "__exception_top@GOTPCREL(%%rip)"]]]
//	[COPY [INDIRECT [ADD [CONST "0"] $T]] $0]
//    ]

//rewrite inst = [TRY tvi addr] 0
//    [LIST
//        [COPY [INDIRECT $1] $0] // [GLOBAL "%%fs:__exception_top@TPOFF"]] $0]
//    ]

// end try block. throw a stop exception, which executes the immediately following
// finally block and then falls through into the code following the try { } finally { } statement:
rewrite inst = END_TRY 0
    [LIST
        [COMMENT "try block completed without encountering exception. Excecute finally and continue"]
	// do not propogate this exception:
	[COPY $T [CONST "0"]]	      
        [ARG0 $T [COMMENT "finally"]]
	// fall through to finally handler:
    ]


rewrite inst = END_CATCH 0
    [LIST
        [COMMENT "exception handled - throw a stop exception to outer handler"]
	// do not propogate this exception:
	[COPY $T [CONST "0"]]	      
        [ARG0 $T [COMMENT "finally"]]
	// jump to outer handler:
	[JUMP $A.S]
    ]

rewrite inst = [COND_RETHROW t t] 0 
    [LIST
	// any non-zero exception type is rethrown:
        [COPY $T [CMP $0 [CONST 0]]]
        [ARG0 $0.T [ARG1 $1 [COMMENT "conditional rethrow"]]]
	// fixme: hope no spill here...
	[COMMENT "exception not handled - throw unhandled exception to outer handler"]
        [JNE $T $A.S]
	[COMMENT "exception handled - fall through to enclosing code"]
    ]


// after outermost exception handler:
// check exception type:
//   3: return exception - place exception value in return register and jump to supplied return label
//   0: handled exception - fall through - exception handling completed
//   other: unhandled exception - rethrow via __throw_endfinally
rewrite inst = [END_FINALLY t t] 0 
    [LIST
        // handle return (throw type 3) by jumping to return label:
	[COPY $T [CMP $0 [CONST 3]]]
	[RESULT $1]
	[JE $T $A.S]

	// handled exception (throw type 0) falls through:
        [COPY $U [CMP $0.T [CONST 0]]]
        [JE $U $L]

	// anything else we rethrow:
        [ARG0 $0.T [ARG1 $1.T [COMMENT "conditional rethrow"]]]
	[CALL "__throw_endfinally"]
	[LABEL $L]
    ]

rewrite inst = SUSPEND_CATCH 0 [COPY [INDIRECT [ADD [CONST 20] [REGISTER 8]]] [CONST "-1"]]

rewrite mem = [INDIRECT [GLOBAL_8]] 0 "$0"

// machine global = GLOBAL_8 0 [Const $A.S]
rewrite const = GLOBAL_8 0 "$0"
machine const = GLOBAL_8 0 [Const $A.S]
rule const = CONST_8 0 [Const $A.S]
rule const = LABEL 50 [Const $A.S]
rule const = DLABEL 50 [Const $A.S]

rule const = [SEQ_8 inst const] 0 [Seq $0 $1]

machine immed = GLOBAL_8 0 [Immediate $A.S]
rewrite immed = GLOBAL_8 0 "$0"
rule immed = CONST_8 0 [Immediate $A.S]
rule immed = CONST_4 0 [Immediate $A.S]
rule immed = CONST_1 0 [Immediate $A.S]
// rule immed = LABEL_4 0 [Immediate $A.S]

rule immed = [SEQ_8 inst immed] 0 [Seq $0 $1]
// rule global = [SEQ_8 inst global] 0 [Seq $0 $1]
 
rule mem = [INDIRECT_8 addr] 10 [Indirect $0]
rule mem = [INDIRECT_4 addr] 10 [Indirect $0]
rule mem = [INDIRECT_1 addr] 10 [Indirect $0]


// force indirect references into temporaries when optimizing to give CSE something to work with:
// rewrite mem = [INDIRECT_8 addr] {a.a3(1)} [SEQ [COPY $T [INDIRECT $0]] $t]
// rewrite mem = [INDIRECT_4 addr] {a.a3(1)} [SEQ [COPY $T [INDIRECT $0]] $t]
// rewrite mem = [INDIRECT_1 addr] {a.a3(1)} [SEQ [COPY $T [INDIRECT $0]] $t]


// temporary - hard or soft register, available to write to
// reg var - register variable, contents must be preserved (unless explicitly stored to)

rule t = TEMP_8 0 [Reg $A.I MSet.General]
rule t = TEMP_4 0 [Reg $A.I MSet.General]
rule t = TEMP_1 0 [Reg $A.I MSet.General]

rule t = REGISTER_8 0 [Reg $A.I]
rule t = REGISTER_4 0 [Reg $A.I]
rule t = REGISTER_1 0 [Reg $A.I]

rule arg = [COMMENT] 10 [Const $A.S]

rule inst = arg 0 [Inst $0]


rule arg = [ARG0_8 t arg] 0 [Arg ARG0 $0:Param0 $1]
rule arg = [ARG1_8 t arg] 0 [Arg ARG1 $0:Param1 $1]
rule arg = [ARG2_8 t arg] 0 [Arg ARG2 $0:Param2 $1]
rule arg = [ARG3_8 t arg] 0 [Arg ARG3 $0:Param3 $1]
rule arg = [ARG4_8 t arg] 0 [Arg ARG4 $0:Param4 $1]
rule arg = [ARG5_8 t arg] 0 [Arg ARG5 $0:Param5 $1]

rule param = [COMMENT] 10 [Const $A.S]
rule param = [RESULT_8 t] 40 [Arg PARAM0 $0:Return [Const "return"]]

rule inst = param 0 [Inst $0]

rule param = [PARAM0_8 t param] 0 [Arg PARAM0 $0:Param0 $1]
rule param = [PARAM1_8 t param] 0 [Arg PARAM1 $0:Param1 $1]
rule param = [PARAM2_8 t param] 0 [Arg PARAM2 $0:Param2 $1]
rule param = [PARAM3_8 t param] 0 [Arg PARAM3 $0:Param3 $1]
rule param = [PARAM4_8 t param] 0 [Arg PARAM4 $0:Param4 $1]
rule param = [PARAM5_8 t param] 0 [Arg PARAM5 $0:Param5 $1]

// rule inst = [SEQ_4 inst inst] 0 [Seq $0 $1]

rewrite tv = [SEQ_8 inst tv] 0 [SEQ $0 $1]
rewrite tv = [SEQ_4 inst tv] 0 [SEQ $0 $1]
rewrite tv = [SEQ_1 inst tv] 0 [SEQ $0 $1]

rewrite v = REG_VAR_8 0 [TEMP $A.I]
rewrite v = REG_VAR_4 0 [TEMP $A.I]
rewrite v = REG_VAR_1 0 [TEMP $A.I]

rewrite tvm = mem 0 "$0"
rewrite tvm = tv 0 "$0"
rewrite tvmi = tvm 0 "$0"
rewrite tvmi = immed 0 "$0"
rewrite tv = t 0 "$0"
rewrite tv = v 0 "$0"
rewrite tvi = tv 0 "$0"
rewrite tvi = immed 0 "$0"

rewrite inst = tv 0 "$0"

machine tm = t 0 "$0"
machine tm = mem 0 "$0"
machine tmi = tm 0 "$0"
machine tmi = immed 0 "$0"
machine ti = t 0 "$0"
machine ti = immed 0 "$0"

machine t = [SEQ_8 inst t] 0 [Seq $0 $1]
machine t = [SEQ_4 inst t] 0 [Seq $0 $1]
machine t = [SEQ_1 inst t] 0 [Seq $0 $1]


machine inst = tmi 0 "$0"


rewrite base = [ADD_8 const tv] 0 [ADD $0 $1]
rewrite base = [ADD_8 tv const] 0 [ADD $1 $0]
rewrite base = tv 0 [ADD [CONST "0"] $0]
rule base = const 0 "$0"

machine base = [ADD_8 const t] 0 [Base ADD $0 $1]

rewrite index = [MUL_8 tv const] { a.scaleRight(1,32768) } [MUL $0 $1]
rewrite index = [MUL_8 const tv] { a.scaleLeft(1,32768) } [MUL $1 $0]
rewrite index = tv 1 [MUL $0 [CONST "1"]]

machine index = [MUL_8 t const] 1 [Index MUL $0 $1]

rule addr = [ADD_8 base index]  0	[Address $0 $1]
rewrite addr = [ADD_8 index base]  0	[ADD $1 $0]
rewrite addr = base 0			"$0"
rewrite addr = index 0			"$0"
rewrite addr = LOCAL_8  0 		[ADD [CONST $V] [REGISTER 7]]
rewrite addr = LOCAL_4  0 		[ADD-8 [CONST $V] [REGISTER 7]]
rewrite addr = LOCAL_1  0		[ADD-8 [CONST $V] [REGISTER 7]]

machine addr = base  0 			[Address $0 null]
machine addr = index  0 		[Address null $0]

rule inst = [ENTER] 0 [Inst [Data ENTER]]
rule inst = [LEAVE] 0 [Inst [Data LEAVE]]

machine inst = [RESULT_8 t] 10 [Inst [Arg RESULT_8 $0:Return [Const "return value"]]]

machine inst = [ADD2_8 tm ti] 10 [Inst [A2 ADD2_8 $0 $1]]
machine inst = [ADD2_8 t tm] 10 [Inst [A2 ADD2_8 $0 $1]]
machine inst = [SUB2_8 tm ti] 10 [Inst [A2 SUB2_8 $0 $1]]
machine inst = [SUB2_8 t tm] 10 [Inst [A2 SUB2_8 $0 $1]]
// multiply accumulator by immediate, left operand must be EAX, terrible instruction to pick, probably should ignore
machine inst = [MUL2_8 t immed] 10 [Inst [A2 MUL2_8 $0 $1]]
// multiply register by register/memory: ModRM
machine inst = [MUL2_8 t tm] 10 [Inst [A2 MUL2_8 $0 $1]]
machine inst = [COPY_8 t [MUL_8 tm immed]] 10 [Inst [A3 MUL_8 $0 $1 $2]]
machine inst = [AND2_8 tm ti] 10 [Inst [A2 AND2_8 $0 $1]]
machine inst = [AND2_8 t tm] 10 [Inst [A2 AND2_8 $0 $1]]
machine inst = [OR2_8 tm ti] 10 [Inst [A2 OR2_8 $0 $1]]
machine inst = [OR2_8 t tm] 10 [Inst [A2 OR2_8 $0 $1]]
machine inst = [XOR2_8 tm ti] 10 [Inst [A2 XOR2_8 $0 $1]]
machine inst = [XOR2_8 t tm] 10 [Inst [A2 XOR2_8 $0 $1]]
machine inst = [SHL2_8 tm t] 10 [Inst [A2 SHL_8 $0 $1:Param3]]
machine inst = [SHAR2_8 tm t] 10 [Inst [A2 SHAR_8 $0 $1:Param3]]
machine inst = [NEG2_8 tm] 10 [Inst [A1 NEG2_8 $0]]
machine inst = [NOT2_8 tm] 10 [Inst [A1 NOT2_8 $0]]



machine inst = [ADD2_4 tm ti] 10 [Inst [A2 ADD2_4 $0 $1]]
machine inst = [ADD2_4 t tm] 10 [Inst [A2 ADD2_4 $0 $1]]
machine inst = [SUB2_4 tm ti] 10 [Inst [A2 SUB2_4 $0 $1]]
machine inst = [SUB2_4 t tm] 10 [Inst [A2 SUB2_4 $0 $1]]
// multiply accumulator by immediate, left operand must be EAX, terrible instruction to pick, probably should ignore
machine inst = [MUL2_4 t immed] 10 [Inst [A2 MUL2_4 $0 $1]]
// multiply register by register/memory: ModRM
machine inst = [MUL2_4 t tm] 10 [Inst [A2 MUL2_4 $0 $1]]
machine inst = [COPY_4 t [MUL_4 tm immed]] 10 [Inst [A3 MUL_4 $0 $1 $2]]
machine inst = [AND2_4 tm ti] 10 [Inst [A2 AND2_4 $0 $1]]
machine inst = [AND2_4 t tm] 10 [Inst [A2 AND2_4 $0 $1]]
machine inst = [OR2_4 tm ti] 10 [Inst [A2 OR2_4 $0 $1]]
machine inst = [OR2_4 t tm] 10 [Inst [A2 OR2_4 $0 $1]]
machine inst = [XOR2_4 tm ti] 10 [Inst [A2 XOR2_4 $0 $1]]
machine inst = [XOR2_4 t tm] 10 [Inst [A2 XOR2_4 $0 $1]]
machine inst = [SHL2_4 tm t] 10 [Inst [A2 SHL_4 $0 $1:Param3]]
machine inst = [SHAR2_4 tm t] 10 [Inst [A2 SHAR_4 $0 $1:Param3]]
machine inst = [NEG2_4 tm] 10 [Inst [A1 NEG_4 $0]]
machine inst = [NOT2_4 tm] 10 [Inst [A1 NOT_4 $0]]



machine inst = [ADD2_1 tm ti] 10 [Inst [A2 ADD2_1 $0 $1]]
machine inst = [ADD2_1 t tm] 10 [Inst [A2 ADD2_1 $0 $1]]

machine inst = [SUB2_1 tm ti] 10 [Inst [A2 SUB2_1 $0 $1]]
machine inst = [SUB2_1 t tm] 10 [Inst [A2 SUB2_1 $0 $1]]

// multiply accumulator by immediate, left operand must be EAX, terrible instruction to pick, probably should ignore
machine inst = [MUL2_1 t immed] 10 [Inst [A2 MUL2_1 $0 $1]]

// multiply register by register/memory: ModRM
machine inst = [MUL2_1 t tm] 10 [Inst [A2 MUL2_1 $0 $1]]

machine inst = [COPY_1 t [MUL_1 tm immed]] 10 [Inst [A3 MUL_1 $0 $1 $2]]

machine inst = [AND2_1 tm ti] 10 [Inst [A2 AND2_1 $0 $1]]
machine inst = [AND2_1 t tm] 10 [Inst [A2 AND2_1 $0 $1]]
machine inst = [OR2_1 tm ti] 10 [Inst [A2 OR2_1 $0 $1]]
machine inst = [OR2_1 t tm] 10 [Inst [A2 OR2_1 $0 $1]]
machine inst = [XOR2_1 tm ti] 10 [Inst [A2 XOR2_1 $0 $1]]
machine inst = [XOR2_1 t tm] 10 [Inst [A2 XOR2_1 $0 $1]]
machine inst = [SHL2_1 tm t] 10 [Inst [A2 SHL_1 $0 $1:Param3]]
machine inst = [SHAR2_1 tm t] 10 [Inst [A2 SHAR_1 $0 $1:Param3]]
machine inst = [NEG2_1 tm] 10 [Inst [A1 NEG_1 $0]]
machine inst = [NOT2_1 tm] 10 [Inst [A1 NOT_1 $0]]


// divide register by register/memory: ModRM
machine inst = [DIV_8 [PAIR_8 t tm] t] 10 [Inst [Divide DIV_8 $0:Return $1:Preserve $2:Param2]]
machine inst = [DIV_4 [PAIR_4 t tm] t] 10 [Inst [Divide DIV_4 $0:Return $1:Preserve $2:Param2]]
machine inst = [DIV_1 [PAIR_1 t tm] t] 10 [Inst [Divide DIV_1 $0:Return $1:Preserve $2:Param2]]
// machine inst = [DIVR_8 [PAIR_8 t tm] t] 10 [Inst [Divide DIVR $0:Return8 $1 $2:Param2]]

// $2 is set Preserve to avoid it ending up in rdx - not sure mod is common enough to
// create a new register set just for this instruction:

machine inst = [MOD_8 [PAIR_8 t t] tm] 10 [Inst [Divide MOD_8 $0:Param2 $1:Return $2:Preserve]]
machine inst = [MOD_4 [PAIR_4 t t] tm] 10 [Inst [Divide MOD_4 $0:Param2 $1:Return $2:Preserve]]
machine inst = [MOD_1 [PAIR_1 t t] tm] 10 [Inst [Divide MOD_1 $0:Param2 $1:Return $2:Preserve]]

rule inst = LABEL 0 [Inst [Label LABEL $A.S]]
rule inst = DLABEL 0 [Inst [Label DLABEL $A.S]]
rule inst = EXTERN 0 [Inst [A1 EXTERN [Const $A.S]]]
rule inst = SAVE_ALL 0 [Inst [A0 SAVE_ALL]]
rule inst = RESTORE_ALL 0 [Inst [A0 RESTORE_ALL]]

rewrite inst = RESERVE 10 [SUB2 [REGISTER 8] [CONST $A.S]]
rewrite inst = RELEASE 10 [ADD2 [REGISTER 8] [CONST $A.S]]

rewrite inst = [THROW_RETURN_8 tv] 10
    [LIST
	[COMMENT "throw return"]
	[COPY $T [CONST "3"]]
        [ARG0 $T [ARG1 $0 [COMMENT "throw return"]]]
	[JUMP $A.V]
    ]

//rewrite inst = [START_CATCH] { ITree.wantPIC(0,32768) }
//    [LIST
//        [COPY $T [INDIRECT [GLOBAL "__exception_top@GOTPCREL(%%rip)"]]]
//	[COPY [INDIRECT [ADD [CONST "0"] $T]] [REGISTER 8]]
//    ]

//rewrite inst = [START_CATCH addr]
//    [LIST
//        [COPY [INDIRECT $0] [REGISTER 8]]
//    ]


rule inst = RET 10 [Inst [A0 RET]]
rule inst = ENTER_LOOP 10 [Inst [A0 ENTER_LOOP]]
rule inst = LEAVE_LOOP 10 [Inst [A0 LEAVE_LOOP]]
rewrite inst = [BOUNDS tv tv] 10
    [LIST
	[*BRANCH [LTU $1 [INDIRECT [ADD [CONST "8"] $0]]] $L]
	[CALL "__throw_arrayboundsexception"]
	[LABEL $L]
    ]

rewrite inst = [BOUNDS_R tv tv] 10
    [*BRANCH [GEU $1 [INDIRECT [ADD [CONST "8"] $0]]] $A.S]

rewrite inst = [BOUNDS_L] 10
    [LIST
	[LABEL $A.S]
	[CALL "__throw_arrayboundsexception"]
    ]

rewrite t = [NEW t tvi] 10
    [SEQ
	[LIST
	    [COPY $T $1]
	    [ARG1 $T [ARG0 $0 [COMMENT "last arg"]]]
	    [STATIC_CALL $U "__alloc_object"]
        ]
        $U
    ]

rewrite t = [NEW_FINALIZE t tvi] 10
    [SEQ
        [LIST
	    [COPY $T $1]
	    [ARG1 $T [ARG0 $0 [COMMENT "last arg"]]]
	    [STATIC_CALL $U "__alloc_object_finalize"]
        ]
        $U
    ]

rewrite t = [NEW_OBJ_ARRAY t] 10
    [SEQ
	[LIST
	    [ARG0 $0 [COMMENT "last arg"]]
	    [STATIC_CALL $T "allocao"]
        ]
        $T
    ] 

rewrite t = [NEW_ARRAY t] 10
    [SEQ
	[LIST
            [ARG0 $0 [COMMENT "last arg"]]
	    [COPY $U [CONST $A.S]]
	    [ARG1 $U [COMMENT "last arg"]]
	    [STATIC_CALL $T "alloca"]
        ]
        $T
    ]

// $0:element-count $1:vtable $A.S:element-size
rewrite t = [NEW_GENERIC_ARRAY t tv] 10
    [SEQ
        [LIST
	    [COPY $U [CONST $A.S]] // element size
	    // arg0/rdi:element count
	    // arg1/rsi:element size
	    // arg2/rdx:vtable
	    [ARG2 $1 [ARG1 $U [ARG0 $0 [COMMENT "last arg"]]]]
	    [STATIC_CALL $T "allocag"]
	]
	$T
    ]
	        

// rewrite inst = [DEFINT_8] 10 [DEFINT $A.S]



rewrite t = [PROC_REF] 10
    [SEQ
	[COPY $U [CONST 32]]
        [ARG0 $U [COMMENT "alloc proc ref"]]
	[STATIC_CALL $T "GC_malloc"]
        $T
    ]
    


rewrite inst = [PROC_CALL t t] 10 
    [LIST
        [RESULT $0]
	[PROC_CALL $0.T]
	[COPY $1.T $0.T]
    ]

// [PROC_CALL $0 $1]

rewrite inst = [PROC_CALL_DISCARD t] 10 
    [LIST
        [RESULT $0]
	[PROC_CALL_DISCARD $0.T]
    ]

// [PROC_CALL_DISCARD $0]

rewrite inst = [STATIC_CALL t] 10 [STATIC_CALL $0.T $A.S]

// FIXME: rax = 0 for va_args/printf 
rewrite inst = [STATIC_CALL_DISCARD] 10 [STATIC_CALL_DISCARD $A.S]

rewrite inst = [DYNAMIC_CALL t] 10 [LIST [COPY $0.T [INDIRECT [ADD [CONST "0"] [REGISTER 6]]]] [DYNAMIC_CALL $0.T [INDIRECT [ADD [CONST $A.S] $0.T]]]]

rewrite inst = [DYNAMIC_CALL_DISCARD] 10 [LIST [COPY [REGISTER 1] [INDIRECT [ADD [CONST "0"] [REGISTER 6]]]] [DYNAMIC_CALL_DISCARD [INDIRECT [ADD [CONST $A.S] [REGISTER 1]]]]]

// rewrite t = [STATIC_DYNAMIC_CALL_8 tvmi] 10 [SEQ [LIST [PUSH $0] [STATIC_CALL_8 $T $A.S]] $T]
// rewrite inst = [STATIC_DYNAMIC_CALL_DISCARD_8 tvmi] 10 [LIST [PUSH $0] [STATIC_CALL_DISCARD_8 $A.S]]
rewrite inst = [CALL] 10 [CALL $A.S]

rewrite inst = [THROW_8 t] 10
    [LIST
        [ARG0 $0 [COMMENT "last arg"]]
        [CALL "__throw_exception"]
    ]

rule inst = DUMMY_JUMP 10 [Inst [Jump DUMMY_JUMP null [Const $A.S]]]


// machine const = [RELOC_0 global const] 0 [Reloc ADD $0 $1]

  
machine inst = [CALL] 10 [Inst [Call STATIC_CALL null [Const $A.S]]]
machine inst = [STATIC_CALL t] 10 [Inst [Call STATIC_CALL $0:Return [Const $A.S]] :CallR]
machine inst = [STATIC_CALL_DISCARD] 10 [Inst [Call STATIC_CALL null [Const $A.S]] :CallD]
machine inst = [DYNAMIC_CALL t tm] 10 [Inst [Call DYNAMIC_CALL $0:Return $1] :CallR]
machine inst = [DYNAMIC_CALL_DISCARD tm] 10 [Inst [Call DYNAMIC_CALL null $0] :CallD]

machine inst = [PROC_CALL t] 10 [Inst [Call PROC_CALL $0:Return null] :CallR]
machine inst = [PROC_CALL_DISCARD t] 10 [Inst [Call PROC_CALL null $0:Return] :CallR]

machine flags = t 0 [Reg $0.T MSet.Flags]

machine inst = [COPY_8 flags [CMP_8 tm ti]] 10 [Inst [Compare CMP_8 $0:Flags $1 $2]]
machine inst = [COPY_8 flags [CMP_8 t tmi]] 10 [Inst [Compare CMP_8 $0:Flags $1 $2]]
machine inst = [COPY_8 flags [CMP_4 tm ti]] 10 [Inst [Compare CMP_4 $0:Flags $1 $2]]
machine inst = [COPY_8 flags [CMP_4 t tmi]] 10 [Inst [Compare CMP_4 $0:Flags $1 $2]]
machine inst = [COPY_8 flags [CMP_1 tm ti]] 10 [Inst [Compare CMP_1 $0:Flags $1 $2]]
machine inst = [COPY_8 flags [CMP_1 t tmi]] 10 [Inst [Compare CMP_1 $0:Flags $1 $2]]
// machine flags = [SEQ_8 flags1 t] 0 [Seq $0:Flags $1:Flags]

machine inst = [JE flags] 10 [Inst [Jump JE $0:Flags [Const $A.S]]]
machine inst = [JNE flags] 10 [Inst [Jump JNE $0:Flags [Const $A.S]]]
machine inst = [JG flags] 10 [Inst [Jump JG $0:Flags [Const $A.S]]]
machine inst = [JGE flags] 10 [Inst [Jump JGE $0:Flags [Const $A.S]]]
machine inst = [JL flags] 10 [Inst [Jump JL $0:Flags [Const $A.S]]]
machine inst = [JLE flags] 10 [Inst [Jump JLE $0:Flags [Const $A.S]]] 
machine inst = [JGU flags] 10 [Inst [Jump JGU $0:Flags [Const $A.S]]]
machine inst = [JGEU flags] 10 [Inst [Jump JGEU $0:Flags [Const $A.S]]]
machine inst = [JLU flags] 10 [Inst [Jump JLU $0:Flags [Const $A.S]]]
machine inst = [JLEU flags] 10 [Inst [Jump JLEU $0:Flags [Const $A.S]]] 

machine inst = [SETE_1 t flags] 10 [Inst [CondSet SETE_1 $0 $1:Flags]]
machine inst = [SETNE_1 t flags] 10 [Inst [CondSet SETNE_1 $0 $1:Flags]]
machine inst = [SETG_1 t flags] 10 [Inst [CondSet SETG_1 $0 $1:Flags]]
machine inst = [SETGE_1 t flags] 10 [Inst [CondSet SETGE_1 $0 $1:Flags]]
machine inst = [SETL_1 t flags] 10 [Inst [CondSet SETL_1 $0 $1:Flags]]
machine inst = [SETLE_1 t flags] 10 [Inst [CondSet SETLE_1 $0 $1:Flags]]
machine inst = [SETGU_1 t flags] 10 [Inst [CondSet SETGU_1 $0 $1:Flags]]
machine inst = [SETGEU_1 t flags] 10 [Inst [CondSet SETGEU_1 $0 $1:Flags]]
machine inst = [SETLU_1 t flags] 10 [Inst [CondSet SETLU_1 $0 $1:Flags]]
machine inst = [SETLEU_1 t flags] 10 [Inst [CondSet SETLEU_1 $0 $1:Flags]]

machine inst = [JUMP] 10 [Inst [Jump JUMP null [Const $A.S]]]

machine inst = [COPY_8 tm ti] 5 [Inst [Move COPY_8 $0 $1]]
machine inst = [COPY_8 t tmi] 5 [Inst [Move COPY_8 $0 $1]]

machine inst = [COPY_4 tm ti] 5 [Inst [Move COPY_4 $0 $1]]
machine inst = [COPY_4 t tmi] 5 [Inst [Move COPY_4 $0 $1]]

machine inst = [COPY_1 tm ti] 5 [Inst [Move COPY_1 $0 $1]]
machine inst = [COPY_1 t tmi] 5 [Inst [Move COPY_1 $0 $1]]

machine inst = [LEA_8 t addr] 10 [Inst [Move LEA_8 $0 $1]]

machine inst = [CONST_STR] 0 [Inst [Data CONST_STR [Const $A.S]]]
machine inst = [CONST_CSTR] 0 [Inst [Data CONST_CSTR [Const $A.S]]]

rule inst = [DEFINT_8] 0 [Inst [Data DEFINT_8 [Const $A.S]]]
rule inst = [DEFINT_4] 0 [Inst [Data DEFINT_4 [Const $A.S]]]
rule inst = [DEFINT_1] 0 [Inst [Data DEFINT_1 [Const $A.S]]]

machine inst = [PUSH_8 tm] 10 [Inst [Stack PUSH_8 $0]]
machine inst = [PUSH_8 immed] 10 [Inst [Stack PUSH_8 $0]]
machine inst = [POP_8 tm] 10 [Inst [Stack POP_8 $0]]

machine inst = [LIST inst inst] 0 [List $0 $1]

// machine inst = [CAST_FROM1_4 t] 10 [Inst [A1 CAST_FROM1_4 $0]]
// machine inst = [CAST_FROM1_8 t] 10 [Inst [A1 CAST_FROM1_8 $0]]
// machine inst = [CAST_FROM4_8 t] 10 [Inst [A1 CAST_FROM4_8 $0]] 

machine inst = [CAST_FROM1_4 t immed] 10 [Inst [Move CAST_FROM1_4 $0 $1]]
machine inst = [CAST_FROM1_4 t tm] 10 [Inst [Move CAST_FROM1_4 $0 $1]]

machine inst = [CAST_FROM1_8 t immed] 10 [Inst [Move CAST_FROM1_8 $0 $1]]
machine inst = [CAST_FROM1_8 t tm] 10 [Inst [Move CAST_FROM1_8 $0 $1]]

machine inst = [CAST_FROM4_8 t immed] 10 [Inst [Move CAST_FROM4_8 $0 $1]]
machine inst = [CAST_FROM4_8 t tm] 10 [Inst [Move CAST_FROM4_8 $0 $1]]

machine inst = [TREAT_AS_8 t] 0 [Inst [A1 TREAT_AS_8 $0]]
machine inst = [TREAT_AS_4 t] 0 [Inst [A1 TREAT_AS_4 $0]]
machine inst = [TREAT_AS_1 t] 0 [Inst [A1 TREAT_AS_1 $0]]

machine inst = [NOP] 0 [Inst [A0 NOP]]
machine inst = [UNWIND] 0 [Inst [Data UNWIND]]
machine inst = [LINE] 0 [Inst [Data LINE [Const $A.S]]]