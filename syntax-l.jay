%{

import parsetree;

namespace Parse {

class Root {
    public static Package root;
}

%}

/* uncomment for yyextract: 
%token FIRST           

%token ARRAY_DEF         
%token BOOL	       
%token BYTE	       
%token CHAR	       
%token INT 	       
%token LONG 	       
%token WORD 	       
%token POINTER 	       
%token REFERENCE       

%token ADD 	      
%token AND 	      
%token ASSERT 	      
%token ASSIGN	      
%token AT	      
%token BOOL_AND	      
%token BOOL_NOT	      
%token BOOL_OR	      
%token BREAK	      
%token CASE	      
%token CAST	      
%token CATCH	      
%token CLASS	       
%token CLOSE_GENERIC  
%token CLOSE_PAREN    
%token CLOSE_SQUARE   
%token COLON	      
%token COMMA	      
%token CONST	      
%token CONST_CHAR     
%token CONST_CSTRING  
%token CONST_DOUBLE   
%token CONST_FALSE    
%token CONST_INT      
%token CONST_NULL     
%token CONST_STRING   
%token CONST_TRUE     
%token CONTINUE	      
%token DEFAULT	      
%token DIV	      
%token DO	      
%token DOT	      
%token ELSE	      
%token END_BLOCK      
%token END_STATEMENT  
%token ENUM	      
%token EOF	      
%token EQ	      
%token EXTENDS	      
%token FINALLY	      
%token FOR	      
%token FOREACH	      
%token GE	      
%token GET	      
%token GT	      
%token IDENTIFIER     
%token IF	      
%token IMPORT	      
%token LE	      
%token LT	      
%token METHOD	      
%token MOD	      
%token MUL	      
%token NAMESPACE      
%token NATIVE	      
%token NE	      
%token NEW	      
%token NEWLINE	      
%token NOT	      
%token OBJ_EQ	      
%token OBJ_NE	      
%token OPEN_GENERIC   
%token OPEN_PAREN     
%token OPEN_SQUARE    
%token OR	      
%token PRAGMA
%token PRIVATE	      
%token PROTECTED      
%token PUBLIC	      
%token RETURN	      
%token SET	      
%token SHIFT_LEFT     
%token SHIFT_RIGHT    
%token START_BLOCK    
%token STATIC	      
%token STRUCT	      
%token SUB	      
%token SUPER	      
%token SWITCH	      
%token THEN	      
%token THIS	      
%token THREAD	      
%token THROW	     
%token TRY	     
%token USE	     
%token VARIABLE	     
%token VECTOR	     
%token VOID	     
%token WHILE	     
%token XOR	     
%token IMPLEMENTS    
%token INTERFACE     
%token PROC          
*/

%token FIRST           0

%token ARRAY_DEF       1 
%token BOOL	       2
%token BYTE	       3
%token CHAR	       4
%token INT 	       5
%token LONG 	       6
%token WORD 	       7
%token POINTER 	       8
%token REFERENCE       9

%token ADD 	      10
%token AND 	      11
%token ASSERT 	      12
%token ASSIGN	      13
%token AT	      14
%token BOOL_AND	      15
%token BOOL_NOT	      16
%token BOOL_OR	      17
%token BREAK	      18
%token CASE	      19
%token CAST	      20
%token CATCH	      21
%token CLASS	      22 
%token CLOSE_GENERIC  23
%token CLOSE_PAREN    24
%token CLOSE_SQUARE   25
%token COLON	      26
%token COMMA	      27
%token CONST	      28
%token CONST_CHAR     29
%token CONST_CSTRING  30
%token CONST_DOUBLE   31
%token CONST_FALSE    32
%token CONST_INT      33
%token CONST_NULL     34
%token CONST_STRING   35
%token CONST_TRUE     36
%token CONTINUE	      37
%token DEFAULT	      38
%token DIV	      39
%token DO	      40
%token DOT	      41
%token ELIF	      42
%token ELSE	      43
%token END	      44
%token END_BLOCK      45
%token END_STATEMENT  46
%token ENUM	      47
%token EOF	      48
%token EQ	      49
%token ESAC	      50
%token EXTENDS	      51
%token FI	      52
%token FINALLY	      53
%token FOR	      54
%token FOREACH	      55
%token GE	      56
%token GET	      57
%token GT	      58
%token IDENTIFIER     59
%token IF	      60
%token IMPORT	      61
%token IS	      62
%token LE	      63
%token LT	      64
%token METHOD	      65
%token MOD	      66
%token MUL	      67
%token NAMESPACE      68
%token NATIVE	      69
%token NE	      70
%token NEW	      71
%token NEWLINE	      72
%token NOT	      73
%token OBJ_EQ	      74
%token OBJ_NE	      75
%token OD	      76
%token OF	      77
%token OPEN_GENERIC   78
%token OPEN_PAREN     79
%token OPEN_SQUARE    80
%token OR	      81
%token PRAGMA	      82
%token PRIVATE	      83
%token PROTECTED      84
%token PUBLIC	      85
%token QUESTION	      86
%token RETURN	      87
%token SET	      88
%token SHIFT_LEFT     89
%token SHIFT_RIGHT    90
%token START_BLOCK    91
%token STATIC	      92
%token STRUCT	      93
%token SUB	      94
%token SUPER	      95
%token SWITCH	      96
%token THEN	      97
%token THIS	      98
%token THREAD	      99
%token THROW	     100
%token TRY	     101
%token UNKNOWN	     102
%token UNTIL	     103
%token USE	     104
%token VARIABLE	     105
%token VECTOR	     106
%token VOID	     107
%token WHILE	     108
%token XOR	     109
%token YRT	     110
%token DO_WHILE      111
%token IMPLEMENTS    112
%token INTERFACE     113
%token PROC          114
%start ROOT

%%

ROOT:
	package { Root.root = cast<Parse.Package>($1); }
;

package:
	class_list { $$ = new Parse.Package( 0, cast<Parse.BlockStatement>($1) ); }
;

class_thing:
	class |
	interface |
	struct |
	namespace |
	use |
	enumeration |
	import | 
	pragma
;

pragma:
	PRAGMA identifier_list END_STATEMENT
	       { $$ = new Parse.Pragma( first_line, cast<Parse.IdentifierList>($2) ); }
;



class_list:
	class_thing { $$ = new Parse.BlockStatement( /*@1.*/first_line, cast<Parse.Statement>($1) ); }
|   class_list class_thing { cast<Parse.BlockStatement>($1).add( cast<Parse.Statement>($2) ); $$ = $1; }
;

namespace:
	NAMESPACE name START_BLOCK END_BLOCK { $$ = new Parse.NameSpace( /*@1.*/first_line, cast<Parse.Identifier>($2), null ); } |
	NAMESPACE name START_BLOCK class_list END_BLOCK { $$ = new Parse.NameSpace( /*@1.*/first_line, cast<Parse.Identifier>($2), cast<Parse.BlockStatement>($4) ); }
;

use:
	USE name END_STATEMENT { $$ = new Parse.Use( /*@2.*/first_line, cast<Parse.Identifier>($2) ); }
;


class_specifiers:
	access_specifiers |
	{ $$ = new Parse.AccessSpecifier(0,0); }
;

import:
    IMPORT name END_STATEMENT { $$ = new Parse.ImportDef( /*@1.*/first_line, cast<Parse.Identifier>($2) ); } |
    IMPORT constant_string END_STATEMENT { $$ = new Parse.LibraryDef( /*@1.*/first_line, cast<Parse.Constant>($2) ); }
;

struct:
    class_specifiers STRUCT identifier class_body
		{ $$ = new Parse.StructDef(
			/*@1.*/first_line,
			cast<Parse.Identifier>($3),
			cast<Parse.BlockStatement>($4) );
		  cast<Parse.StructDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();
		}
;

class:
    class_specifiers CLASS identifier generic implements class_body
		{ $$ = new Parse.ClassDef(
			/*@1.*/first_line,
			cast<Parse.Identifier>($3),  	  // name
			cast<Parse.IdentifierList>($4),   // generic arguments
			null,			  	  // super class
			null,				  // super class generic arguments
			cast Parse.TypeExprList($5),    // implements
			cast<Parse.BlockStatement>($6) ); // body
		  cast<Parse.ClassDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();
		}
|   class_specifiers CLASS identifier generic EXTENDS name generic_super implements class_body
		{ $$ = new Parse.ClassDef(
		    /*@1.*/first_line,
			cast<Parse.Identifier>($3),		// name
			cast<Parse.IdentifierList>($4),		// generic arguments
			cast<Parse.Identifier>($6),		// super class
			cast<Parse.TypeExprList>($7),		// super class generic arguments
			cast Parse.TypeExprList($8),    // implements
			cast<Parse.BlockStatement>($9) );	// body
		  cast<Parse.ClassDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();
		}
;

interface:
    class_specifiers INTERFACE identifier generic class_body
                { $$ = new Parse.InterfaceDef(
                        first_line,
                        cast<Parse.Identifier>($3),       // name
                        cast<Parse.IdentifierList>($4),   // generic arguments
                        null,                             // super class
                        null,                             // super class generic arguments
                        cast<Parse.BlockStatement>($5) ); // body
                  cast<Parse.ClassDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();
                }
|   class_specifiers INTERFACE identifier generic EXTENDS name generic_super class_body
                { $$ = new Parse.InterfaceDef(
                    first_line,
                        cast<Parse.Identifier>($3),             // name
                        cast<Parse.IdentifierList>($4),         // generic arguments
                        cast<Parse.Identifier>($6),             // super class
                        cast<Parse.TypeExprList>($7),           // super class generic arguments
                        cast<Parse.BlockStatement>($8) );       // body
                  cast<Parse.ClassDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();
                }
;


implements:
       IMPLEMENTS type_list { $$ = $2; }
|
       { $$ = null; }
;
generic:
	OPEN_GENERIC plain_identifier_list CLOSE_GENERIC { $$ = $2; }
|
	{ $$ = new Parse.IdentifierList(first_line,null); }
;

generic_super:
	OPEN_GENERIC type_list CLOSE_GENERIC { $$ = $2; }
|
	{ $$ = new Parse.TypeExprList(first_line); }
;

enumeration:
    class_specifiers ENUM identifier START_BLOCK identifier_list END_BLOCK
	{ $$ = new Parse.EnumDef( /*@3.*/first_line, cast<Parse.Identifier>($3), cast<Parse.IdentifierList>($5) );
		  cast<Parse.EnumDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();

	} |
    class_specifiers ENUM identifier START_BLOCK END_BLOCK
	{ $$ = new Parse.EnumDef( /*@3.*/first_line, cast<Parse.Identifier>($3), cast<Parse.IdentifierList>($5) );
		  cast<Parse.EnumDef>($$).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
                  cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
                  Parse.ParseTree.resetLastComment();
        }
;	

class_body:
	START_BLOCK END_BLOCK {
		$$ = new Parse.BlockStatement( /*@1.*/first_line, new Parse.NullStatement( /*@1.*/first_line ) );
	}
|   START_BLOCK class_body_declarations END_BLOCK {
		$$ = $2;
	}
;

class_body_declarations:
	class_body_declaration {
		$$ = new Parse.BlockStatement(
			/*@1.*/first_line,
			cast<Parse.Statement>($1)
		);
	}
|   class_body_declarations class_body_declaration {
		cast<Parse.BlockStatement>($1).add( cast<Parse.Statement>($2) );
    }
;

class_body_declaration:
	field_declaration
|   method_declaration
|   native_declaration
|   access_specifiers field_declaration {
		cast<Parse.VariableDef>($2).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
		$$ = $2;
	}
|   access_specifiers method_declaration {
		cast<Parse.MethodDef>($2).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
		$$ = $2;
	}
|   access_specifiers native_declaration {
		cast<Parse.NativeDef>($2).setAccess( cast<Parse.AccessSpecifier>($1).getAccess() );
		$$ = $2;
       } 
|   enumeration
|   pragma
;

field_declaration:
    type identifier_list END_STATEMENT {
		$$ = new Parse.VariableDef(
			/*@1.*/first_line,
			cast<Parse.IdentifierList>($2),
			0,
			cast<Parse.TypeExpr>($1)
		);
	}
;

native_declaration:
	NATIVE type identifier declare_arguments END_STATEMENT {
		$$ = new Parse.NativeDef(
			/*@2.*/first_line,
			cast<Parse.Identifier>($3),
			0,
			cast<Parse.TypeExpr>($2),
			cast<Parse.ArgumentsDef>($4)
	        );
        }
;

normal_method_declaration:
	type identifier declare_arguments method_body {
		$$ = new Parse.MethodDef(
			/*@1.*/first_line,
			cast<Parse.Identifier>($2),
			0,
			cast<Parse.TypeExpr>($1),
			cast<Parse.ArgumentsDef>($3),
			cast<Parse.BlockStatement>($4)
		);

		cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($2).Comment;
            	Parse.ParseTree.resetLastComment();
	}
;

accessor_declaration:
     /* 1   2    3          4  */
 	GET type identifier method_body {
	    var name1 = "get" + cast Parse.Identifier($3).Name;
	    var type1 = cast Parse.TypeExpr($2); // .copy();

	    $$ = new Parse.MethodDef(
	        first_line,
	        new Parse.Identifier( first_line, name1 ),
	        0,
	        type1,
	        null,
	        cast Parse.BlockStatement($4)
	    );

	    cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
            Parse.ParseTree.resetLastComment();

        }
|       
     /* 1    2   3          4      5          6 */
	SET type identifier ASSIGN identifier method_body {
	    var name2 = "set" + cast Parse.Identifier($3).Name;
	    var arg_type2 = cast Parse.TypeExpr($2); // .copy();
	    var method_type2 = new Parse.BaseType( first_line, Type.VOID);

	    var args2 = new Parse.ArgumentsDef(
	    	first_line,
		new Parse.VariableDef(
		    first_line,
		    cast Parse.Identifier($5),
		    0,
		    arg_type2
                )
	    );


	    $$ = new Parse.MethodDef(
	        first_line,
		new Parse.Identifier( first_line, name2 ),
                0,
                method_type2,
                args2,
		cast Parse.BlockStatement($6)
            );

	    cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
            Parse.ParseTree.resetLastComment();
        }
;

indexer_declaration:
     /* 1    2   3           4                    5            6 */
	GET type OPEN_SQUARE argument_declaration CLOSE_SQUARE method_body {
	    var name3 = "opGet";
	    var type3 = cast Parse.TypeExpr($2); // .copy();
	    var args3 = new Parse.ArgumentsDef(
	        first_line,
		cast Parse.VariableDef($4)
            );

	    $$ = new Parse.MethodDef(
	       first_line,
	       new Parse.Identifier( first_line, name3 ),
	       0,
	       type3,
	       args3,
	       cast Parse.BlockStatement($6)
	    );

	    cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($2).Comment;
            Parse.ParseTree.resetLastComment();
	}
|
     /* 1    2   3           4                    5            6      7          8 */
	SET type OPEN_SQUARE argument_declaration CLOSE_SQUARE ASSIGN identifier method_body {
	    var name4 = "opSet";
	    var arg_type4 = cast Parse.TypeExpr($2);
	    var ident4 = cast Parse.Identifier($7);
            var method_type4 = new Parse.BaseType( first_line, Type.VOID);

	    var args4 = new Parse.ArgumentsDef(
	        first_line,
		cast Parse.VariableDef($4)
            );

      	    args4.add(
		new Parse.VariableDef(
		    first_line,
		    ident4,
		    0,
		    arg_type4
		)
            );

   	    $$ = new Parse.MethodDef(
	        first_line,
		new Parse.Identifier( first_line, name4 ),
		0,
		method_type4,
		args4,
		cast Parse.BlockStatement($8)
	    );

	    cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($2).Comment;
            Parse.ParseTree.resetLastComment();
        }
;

indexed_accessor_declaration:
     /* 1    2   3          4           5                    6            7 */
	GET type identifier OPEN_SQUARE argument_declaration CLOSE_SQUARE method_body {
	    var name5 = "opGet" + cast Parse.Identifier($3).Name;
	    var type5 = cast Parse.TypeExpr($2); // .copy();
	    var args5 = new Parse.ArgumentsDef(
	        first_line,
		cast Parse.VariableDef($5)
            );

	    $$ = new Parse.MethodDef(
	       first_line,
	       new Parse.Identifier( first_line, name5 ),
	       0,
	       type5,
	       args5,
	       cast Parse.BlockStatement($7)
	    );

	    cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
            Parse.ParseTree.resetLastComment();
        }
|
     /* 1    2   3          4           5                    6            7      8          9 */
	SET type identifier OPEN_SQUARE argument_declaration CLOSE_SQUARE ASSIGN identifier method_body {
	    var name6 = "opSet" + cast Parse.Identifier($3).Name;
	    var arg_type6 = cast Parse.TypeExpr($2);
	    var ident6 = cast Parse.Identifier($8);
            var method_type6 = new Parse.BaseType( first_line, Type.VOID);

	    var args6 = new Parse.ArgumentsDef(
	        first_line,
		cast Parse.VariableDef($5)
            );

      	    args6.add(
		new Parse.VariableDef(
		    first_line,
		    ident6,
		    0,
		    arg_type6
		)
            );

   	    $$ = new Parse.MethodDef(
	        first_line,
		new Parse.Identifier( first_line, name6 ),
		0,
		method_type6,
		args6,
		cast Parse.BlockStatement($9)
	    );

	    cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($3).Comment;
            Parse.ParseTree.resetLastComment();
	}
;


method_declaration:
	normal_method_declaration
|
	accessor_declaration
|
	indexer_declaration
|
	indexed_accessor_declaration
;

method_body:
	block_statement {
	    $$ = $1;
	}
|	END_STATEMENT {
            $$  = new Parse.EmptyBody( first_line );
        }
;


declare_arguments:
	OPEN_PAREN declare_argument_list CLOSE_PAREN {
		$$ = $2;
	}
|	OPEN_PAREN CLOSE_PAREN {
		$$ = null;
	}
;

declare_argument_list:
	argument_declaration {
		$$ = new Parse.ArgumentsDef( /*@1.*/first_line, cast<Parse.VariableDef>($1) );
	}
|   declare_argument_list COMMA argument_declaration {
		cast<Parse.ArgumentsDef>($1).add( cast<Parse.VariableDef>($3) );
		$$=$1;
	}
;


argument_declaration:
    type identifier {
		$$ = new Parse.VariableDef(
			/*@1.*/first_line,
			cast<Parse.Identifier>($2),
			0,
			cast<Parse.TypeExpr>($1)
		);

		cast Parse.ParseTree($$).Comment = cast Parse.ParseTree($2).Comment;
            	Parse.ParseTree.resetLastComment();
	}
;



expression:
	expressionX
;


expressionX:
	expressionX BOOL_AND expression0
		{ $$ = new Parse.BooleanExpression( first_line, Op.BOOL_AND, cast<Parse.Expression>($1), cast<Parse.Expression>($3) ); }
|   expressionX BOOL_OR expression0
		{ $$ = new Parse.BooleanExpression( first_line, Op.BOOL_OR, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expression0
;


expression0:
    BOOL_NOT expression0
		{ $$ = new Parse.BooleanExpression( first_line, Op.BOOL_NOT, cast<Parse.Expression>($2), null ); }
|	expressionA
;




expressionA:
   expressionA EQ expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.EQ, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA NE expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.NE, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA GT expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.GT, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA LT expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.LT, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA GE expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.GE, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA LE expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.LE, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA OBJ_EQ expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.OBJ_EQ, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionA OBJ_NE expressionB
		{ $$ = new Parse.BooleanExpression( first_line, Op.OBJ_NE, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionB
;

expressionB:
    expressionB AND expressionC
		{ $$ = new Parse.ArithExpression( first_line, Op.AND, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionB OR expressionC
		{ $$ = new Parse.ArithExpression( first_line, Op.OR, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionB XOR expressionC
		{ $$ = new Parse.ArithExpression( first_line, Op.XOR, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expressionC
;


expressionC:
	expressionC SHIFT_LEFT expression1 {
		$$ = new Parse.ArithExpression( first_line, Op.SHL, cast<Parse.Expression>($1), cast<Parse.Expression>($3));
	}
|   expressionC SHIFT_RIGHT expression1 {
		$$ = new Parse.ArithExpression( first_line, Op.SHAR, cast<Parse.Expression>($1), cast<Parse.Expression>($3));
	}
|   expression1
;

expression1:
    expression1 ADD expression2
		{ $$ = new Parse.ArithExpression( first_line, Op.ADD, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expression1 SUB expression2
		{ $$ = new Parse.ArithExpression( first_line, Op.SUB, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expression2
;

expression2:
    expression2 MUL expression3
		{ $$ = new Parse.ArithExpression( first_line, Op.MUL, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expression2 DIV expression3
		{ $$ = new Parse.ArithExpression( first_line, Op.DIV, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expression2 MOD expression3
		{ $$ = new Parse.ArithExpression( first_line, Op.MOD, cast<Parse.Expression>($1), cast<Parse.Expression>($3)); }
|   expression3
;


expression3:
	unary_expression
|   NOT expression3
		{ $$ = new Parse.ArithExpression( /*@1.*/first_line, Op.NOT, cast<Parse.Expression>($2), null ); }
;


access_specifiers:
	access_specifiers access_specifier {
		cast<Parse.AccessSpecifier>($1).
			add( cast<Parse.AccessSpecifier>($2).getAccess() );
		$$ = $1;
	}
|   access_specifier
;

access_specifier:
    PUBLIC
		{ $$ = new Parse.AccessSpecifier( /*@1.*/first_line, Symbol.ACCESS_PUBLIC ); }
|   PRIVATE
		{ $$ = new Parse.AccessSpecifier( /*@1.*/first_line, Symbol.ACCESS_PRIVATE ); }
|   PROTECTED
		{ $$ = new Parse.AccessSpecifier( /*@1.*/first_line, Symbol.ACCESS_PROTECTED ); }
|   STATIC
		{ $$ = new Parse.AccessSpecifier( /*@1.*/first_line, Symbol.ACCESS_STATIC ); }
|   CONST
		{ $$ = new Parse.AccessSpecifier( /*@1.*/first_line, Symbol.ACCESS_CONST ); }
;


ident_assign:
    identifier
|   identifier ASSIGN expression {
		$$ = new Parse.IdentifierAssign(
			/*@1.*/first_line, cast<Parse.Identifier>($1),
			cast<Parse.Expression>($3) );
	}
;

plain_identifier_list:
	identifier {
		$$ = new Parse.IdentifierList( first_line, cast<Parse.Identifier>($1) );

	}
|	plain_identifier_list COMMA identifier {
		cast<Parse.IdentifierList>($1).add( cast<Parse.Identifier>($3) ); $$ = $1;
	}
;

identifier_list:
	ident_assign {
		$$ = new Parse.IdentifierList( /*@1.*/first_line, cast<Parse.Identifier>($1) );
	}
|	identifier_list COMMA ident_assign {
		cast<Parse.IdentifierList>($1).add( cast<Parse.Identifier>($3) );
	}
;




empty_statement:
END_STATEMENT	 {
		$$ = new Parse.NullStatement( /*@1.*/first_line );
	}
;



method_call_statement:
	method_call {
		$$ = new Parse.ExpressionStatement( /*@1.*/first_line, cast<Parse.Expression>($1) );
	}
;


labelled_statement:
	identifier COLON loop_statement {
		cast<Parse.Statement>($3).setLoopName( cast<Parse.Identifier>($1) ); $$ = $3; } |
	loop_statement ;

loop_statement:
	foreach_statement |
	for_statement |
	do_statement |
	while_statement ;

do_statement:  DO statement WHILE OPEN_PAREN expression CLOSE_PAREN END_STATEMENT {
		$$ = new Parse.DoWhileStatement( /*@1.*/first_line, cast<Parse.Expression>($5), cast<Parse.Statement>($2) );
};

foreach_statement:
	FOREACH OPEN_PAREN type identifier END_STATEMENT expression CLOSE_PAREN statement {
		$$ = new Parse.ForEachStatement( /*@1.*/first_line, cast<Parse.TypeExpr>($3),
			cast<Parse.Identifier>($4), cast<Parse.Expression>($6), cast<Parse.Statement>($8) );
        } | 
	FOREACH OPEN_PAREN VARIABLE identifier END_STATEMENT expression CLOSE_PAREN statement {
		$$ = new Parse.ForEachStatement( /*@1.*/first_line, new Parse.InferTypeExpr(first_line), 
			cast<Parse.Identifier>($4), cast<Parse.Expression>($6), cast<Parse.Statement>($8) );
        }

;


for_statement:
	FOR OPEN_PAREN within_for_statement expression END_STATEMENT very_simple_statement CLOSE_PAREN statement {
		$$ = new Parse.ForStatement(
			/*@1.*/first_line, cast<Parse.Statement>($3), cast<Parse.Expression>($4), cast<Parse.Statement>($6),
			cast<Parse.Statement>($8) );
        } |
	/* 1  2            3                    4               5 inc                 6             7 */
	FOR OPEN_PAREN within_for_statement END_STATEMENT very_simple_statement CLOSE_PAREN statement {
		$$ = new Parse.ForStatement(
			/*@1.*/first_line, cast<Parse.Statement>($3), null, cast<Parse.Statement>($5),
			cast<Parse.Statement>($7));
        } |
	/* 1  2            3                    4          5               6             7 */
	FOR OPEN_PAREN within_for_statement expression END_STATEMENT CLOSE_PAREN statement {
		$$ = new Parse.ForStatement(
			/*@1.*/first_line, cast<Parse.Statement>($3), cast<Parse.Expression>($4), null,
			cast<Parse.Statement>($7) );
        } |
	/* 1  2            3                    4               5             6 */
	FOR OPEN_PAREN within_for_statement END_STATEMENT CLOSE_PAREN statement {
		$$ = new Parse.ForStatement(
			/*@1.*/first_line, cast<Parse.Statement>($3), null, null,
			cast<Parse.Statement>($6) );
        }


;

switch_statement:
	SWITCH OPEN_PAREN expression CLOSE_PAREN START_BLOCK case_list END_BLOCK { $$ = $6; cast<Parse.CaseStatement>($$).setExpression(cast<Parse.Expression>($3)); } |
	SWITCH OPEN_PAREN expression CLOSE_PAREN START_BLOCK END_BLOCK { $$ = new Parse.CaseStatement( /*@1.*/first_line ); cast<Parse.CaseStatement>($$).setExpression(cast<Parse.Expression>($3) ); }
;

case_list:
	case { $$ = new Parse.CaseStatement( /*@1.*/first_line ); cast<Parse.CaseStatement>($$).add(cast<Parse.Case>($1)); } |
	case_list case { cast<Parse.CaseStatement>($1).add( cast<Parse.Case>($2) ); $$ = $1; } |
	default { $$ = new Parse.CaseStatement( /*@1.*/first_line ); cast<Parse.CaseStatement>($$).setDefault(cast<Parse.BlockStatement>($1));} |
	case_list default { cast<Parse.CaseStatement>($1).setDefault( cast<Parse.BlockStatement>($2) ); $$ = $1; }
;

case:
	CASE expression_list COLON block_statement_list { $$ = new Parse.Case(/*@1.*/first_line, cast<Parse.ExpressionList>($2), cast<Parse.BlockStatement>($4) ); }
;

default:
	DEFAULT COLON block_statement_list { $$ = $3; }
;

if_then_statement:
	IF OPEN_PAREN expression CLOSE_PAREN statement {
		$$ = new Parse.IfStatement(
			/*@1.*/first_line, cast<Parse.Expression>($3),
			cast<Parse.Statement>($5),
			null );
	}
;

if_then_else_statement:
	IF OPEN_PAREN expression CLOSE_PAREN statement_inner ELSE statement	{
		$$ = new Parse.IfStatement(
			/*@1.*/first_line, cast<Parse.Expression>($3),
			cast<Parse.Statement>($5),
			cast<Parse.Statement>($7) );
	}
;

if_then_else_statement_inner:
	IF OPEN_PAREN expression CLOSE_PAREN statement_inner ELSE statement_inner {
		$$ = new Parse.IfStatement( /*@1.*/first_line, cast<Parse.Expression>($3), cast<Parse.Statement>($5), cast<Parse.Statement>($7) );
	}
;

while_statement:
	WHILE OPEN_PAREN expression CLOSE_PAREN statement {
		$$ = new Parse.WhileStatement(
			/*@1.*/first_line,
			cast<Parse.Expression>($3),
			cast<Parse.Statement>($5)
		);
	}
;

while_statement_inner:
	WHILE OPEN_PAREN expression CLOSE_PAREN statement_inner {
		$$ = new Parse.WhileStatement(
			/*@1.*/first_line,
			cast<Parse.Expression>($3),
			cast<Parse.Statement>($5)
		);
	}
;

return_statement:
	RETURN END_STATEMENT {
		$$ = new Parse.ReturnStatement( /*@1.*/first_line, null );
	}
|   RETURN expression END_STATEMENT {
		$$ = new Parse.ReturnStatement( /*@1.*/first_line, cast<Parse.Expression>($2) );
	}
;

throw_statement:
	THROW expression END_STATEMENT {
		$$ = new Parse.ThrowStatement( /*@1.*/first_line, cast<Parse.Expression>($2) );
	}
;

try_statement:
	TRY block_statement catches {
		$$ = new Parse.TryStatement(
			/*@1.*/first_line,
			cast<Parse.Statement>($2),
			cast<Parse.Catches>($3),
			null
		);
	}
|   TRY block_statement finally {
		$$ = new Parse.TryStatement(
			/*@1.*/first_line,
			cast<Parse.Statement>($2),
			new Parse.Catches( /*@1.*/first_line ),
			cast<Parse.Statement>($3)
		);
	}

|   TRY block_statement catches finally {
		$$ = new Parse.TryStatement(
			/*@1.*/first_line,
			cast<Parse.Statement>($2),
			cast<Parse.Catches>($3),
			cast<Parse.Statement>($4)
		);
	}

;

catches:
	catch_clause {
		$$ = new Parse.Catches( /*@1.*/first_line, cast<Parse.Catch>($1) );
	}
|   catches catch_clause {
		cast<Parse.Catches>($1).add( cast<Parse.Catch>($2) );
		$$ = $1;
	}

;

catch_clause:
	CATCH OPEN_PAREN argument_declaration CLOSE_PAREN block_statement {
		$$ = new Parse.Catch(
			/*@1.*/first_line,
			cast<Parse.VariableDef>($3),
			cast<Parse.Statement>($5)
		);
	}
;

finally:
	FINALLY block_statement {
		$$ = $2;
	}
;

break_statement:
	BREAK { $$ = new Parse.BreakStatement( /*@1.*/first_line ); } |
	BREAK identifier { $$ = new Parse.BreakStatement( /*@1.*/first_line ); cast<Parse.Statement>($$).setLoopName(cast<Parse.Identifier>($2)); };

continue_statement:
	CONTINUE { $$ = new Parse.ContinueStatement( /*@1.*/first_line ); } |
	CONTINUE identifier { $$ = new Parse.ContinueStatement( /*@1.*/first_line ); cast<Parse.Statement>($$).setLoopName(cast<Parse.Identifier>($2)); };


statement:
	simple_statement |
	if_then_statement |
	if_then_else_statement |
	labelled_statement |
	switch_statement ;
/*	while_statement |
	for_statement |
	foreach_statement */


within_for_statement:
    very_simple_statement END_STATEMENT |
    local_declaration |
    END_STATEMENT { $$ = null; }
;

very_simple_statement:
    assignment_statement |
    method_call_statement
;

simple_statement:
    very_simple_statement END_STATEMENT |
    block_statement |
    throw_statement |
    return_statement |
    try_statement |
    break_statement END_STATEMENT |
    continue_statement END_STATEMENT |
    empty_statement
;


assignment_statement:
	assignment
;


statement_inner:
	simple_statement
|   if_then_else_statement_inner
|   while_statement_inner
;

local_declaration:
    untyped_declaration {
        $$ = $1;
    } |

    field_declaration {
	$$ = $1;
    }
;

untyped_declaration:
     VARIABLE identifier_list END_STATEMENT {
    	        $$ = new Parse.VariableDef(
		     first_line,
                     cast<Parse.IdentifierList>($2),
		     0,
		     new InferTypeExpr(first_line)
		 );
    }
;


within_block_statement:
	local_declaration
|	pragma
|	statement
;


left_value:
    name
|   pointer_access
|   field_access
|   vector_access
;

assignment:
	left_value ASSIGN expression {
		$$ = new Parse.Assignment(
			/*@2.*/first_line,
			cast<Parse.Expression>($1),
			cast<Parse.Expression>($3)
		);
	}
;


expression_list:
	expression {
		$$ = new Parse.ExpressionList( /*@1.*/first_line, cast<Parse.Expression>($1) );
	}
|	expression_list COMMA expression {
		cast<Parse.ExpressionList>($1).add( cast<Parse.Expression>($3) );
	}
;


block_statement:
	START_BLOCK END_BLOCK {
			$$ = new Parse.BlockStatement( /*@1.*/first_line, null );
	}
|	START_BLOCK block_statement_list END_BLOCK {
		$$ = $2;
	}
;

block_statement_list:
	within_block_statement {
		$$ = new Parse.BlockStatement( /*@1.*/first_line, cast<Parse.Statement>($1) );
	}
|	block_statement_list within_block_statement	{
		cast<Parse.BlockStatement>($1).add( cast<Parse.Statement>($2) );
	}
;

class_qualifier:
        CLASS OPEN_GENERIC type CLOSE_GENERIC {
                $$ = new Parse.ClassQualifier( /*@3.*/first_line, cast<Parse.TypeExpr>($3) );
        }
;


proc_ref:
	type PROC OPEN_PAREN type_list CLOSE_PAREN OPEN_PAREN expression CLOSE_PAREN {
	    $$ =new Parse.ProcRef( first_line, cast<Parse.Expression>($7), cast<Parse.TypeExpr>($1), cast<Parse.TypeExprList>($4) );
        }
|	type PROC OPEN_PAREN CLOSE_PAREN OPEN_PAREN expression CLOSE_PAREN {
	    $$ = new Parse.ProcRef( first_line, cast<Parse.Expression>($6), cast<Parse.TypeExpr>($1), new Parse.TypeExprList(first_line) );
        }
;

field_access:
	primary DOT identifier {
		cast<Parse.Identifier>($3).qualifies(cast<Parse.Expression>($1));
		$$ = $3;
	}

;


generic_type:
       type OPEN_GENERIC type_list CLOSE_GENERIC { $$ = new GenericType( first_line, cast<Parse.TypeExpr>($1), cast<Parse.TypeExprList>($3) ); }
;

method_call:
    thing OPEN_PAREN CLOSE_PAREN {
    	    $$ = new Parse.MethodCall(
			/*@3.*/first_line,
			cast<Parse.Expression>($1),
			cast<Parse.ExpressionList>(null)
		);
	}
|
    thing OPEN_PAREN expression_list CLOSE_PAREN {
		$$ = new Parse.MethodCall(
			/*@3.*/first_line,
			cast<Parse.Expression>($1),
			cast<Parse.ExpressionList>($3)
		);
	}

|   NATIVE DOT identifier OPEN_PAREN CLOSE_PAREN {
		$$ = new Parse.NativeCall(
			/*@3.*/first_line,
			cast<Parse.Identifier>($3),
			cast<Parse.ExpressionList>(null)
		);
	}
|   NATIVE DOT identifier OPEN_PAREN expression_list CLOSE_PAREN {
		$$ = new Parse.NativeCall(
			/*@3.*/first_line,
			cast<Parse.Identifier>($3),
			cast<Parse.ExpressionList>($5)
		);
	}
;

name:
    simple_name
|   qualified_name
;

simple_name:
    identifier
;

qualified_name:
	name DOT identifier {
		cast<Parse.Identifier>($3).qualifies( cast<Parse.Identifier>($1) );
		$$ = $3;
	}
;



unary_expression:
        thing
|   SUB unary_expression {
                $$ = new Parse.ArithExpression( /*@1.*/first_line, Op.NEG, cast<Parse.Expression>($2), cast<Parse.Expression>(null) );
        }
;


thing:
    primary
|   name
;

literal:
    constant_null
|   constant_integer
|   constant_string
|   constant_cstring
|   constant_char
|   constant_double
|   constant_boolean
;


primary:
	literal
|       THIS {
		$$ = new Parse.This( /*@1.*/first_line );
	}
|       SUPER {
	        $$ = new Parse.Super( first_line );
        }
|	vector_list
|	OPEN_PAREN expression CLOSE_PAREN { $$ = $2; }
|	cast
|	new
|       proc_ref
|	field_access
|	method_call
|	vector_access
|       pointer_access
|       class_qualifier
|       generic_type { $$ = new Parse.WrapTypeExprAsExpression(first_line,cast<TypeExpr>($1)); }
;


vector_list:

	NEW type START_BLOCK expression_list END_BLOCK {
		$$ = new Parse.VectorList(
			/*@1.*/first_line,
			cast<Parse.TypeExpr>($2),
			cast<Parse.ExpressionList>($4)
		);
	} |
	NEW type START_BLOCK expression_list COMMA END_BLOCK {
		$$ = new Parse.VectorList(
			/*@1.*/first_line,
			cast<Parse.TypeExpr>($2),
			cast<Parse.ExpressionList>($4)
		);
	} | 
	START_BLOCK expression_list END_BLOCK {
	$$ = new Parse.VectorList(
			/*@1.*/first_line,
			null,
			cast<Parse.ExpressionList>($2)
		);
	} |
	START_BLOCK expression_list COMMA END_BLOCK {
	$$ = new Parse.VectorList(
			/*@1.*/first_line,
			null,
			cast<Parse.ExpressionList>($2)
		);
	}
;


pointer_access:
	OPEN_SQUARE expression CLOSE_SQUARE {
		$$ = new Parse.AtExpression( /*@1.*/first_line, cast<Parse.Expression>($2) );
	} 
;


vector_access:
	name OPEN_SQUARE expression CLOSE_SQUARE {
		$$ =new Parse.VectorAccess(
			/*@2.*/first_line,
			cast<Parse.Expression>($1),
			cast<Parse.Expression>($3)
		);
	}
|   primary OPEN_SQUARE expression CLOSE_SQUARE {
		$$ = new Parse.VectorAccess(
			/*@2.*/first_line,
			cast<Parse.Expression>($1),
			cast<Parse.Expression>($3)
		);
	}
;


cast:
	CAST OPEN_GENERIC type CLOSE_GENERIC OPEN_PAREN expression CLOSE_PAREN
		{ $$ = new Parse.Cast( /*@1.*/first_line, cast<Parse.TypeExpr>($3), cast<Parse.Expression>($6) ); }
|	CAST type OPEN_PAREN expression CLOSE_PAREN
		{ $$ = new Parse.Cast( /*@1.*/first_line, cast<Parse.TypeExpr>($2), cast<Parse.Expression>($4) ); }
;



new:
	NEW type OPEN_SQUARE expression CLOSE_SQUARE {
		$$ = new Parse.NewExpression(
			/*@1.*/first_line, cast<Parse.TypeExpr>($2),
			cast<Parse.Expression>($4)
		);
	}
|   NEW type OPEN_PAREN expression_list CLOSE_PAREN {
		$$ = new Parse.NewExpression(
			/*@1.*/first_line, cast<Parse.TypeExpr>($2),
			cast<Parse.ExpressionList>($4)
		);
	}
|   NEW type OPEN_PAREN CLOSE_PAREN {
		$$ = new Parse.NewExpression(
			/*@1.*/first_line,
			cast<Parse.TypeExpr>($2),
			cast<Parse.ExpressionList>(null)
		);
	}
;


identifier: IDENTIFIER {
	    $$ = new Parse.Identifier( /*@1.*/first_line, cast<String>(yyLex.getValue()));
            cast Parse.ParseTree($$).Comment = Parse.ParseTree.LastComment;
};
constant_null:      CONST_NULL    { $$ = new Parse.Constant( /*@1.*/first_line, Type.NULL, "0" ); };
constant_integer:	CONST_INT	{ $$ = new Parse.Constant( /*@1.*/first_line, Type.INTEGER, cast<String>(yyLex.getValue()) ); };
constant_string:	CONST_STRING	{ $$ = new Parse.Constant( /*@1.*/first_line, Type.STRING, cast<String>(yyLex.getValue()) ); };
constant_cstring:	CONST_CSTRING { $$ = new Parse.Constant( /*@1.*/first_line, Type.CSTRING, cast<String>(yyLex.getValue()) ); };
constant_char:      CONST_CHAR    { $$ = new Parse.Constant( /*@1.*/first_line, Type.CHAR, cast<String>(yyLex.getValue()) ); };
constant_double:	CONST_DOUBLE	{ $$ = new Parse.Constant( /*@1.*/first_line, Type.DOUBLE, cast<String>(yyLex.getValue()) ); };
constant_boolean:   CONST_TRUE    { $$ = new Parse.Constant( /*@1.*/first_line, Type.BOOL, "1" ); }
|                   CONST_FALSE   { $$ = new Parse.Constant( /*@1.*/first_line, Type.BOOL, "0" ); }
;

type:
	name {
	     $$ = new Parse.NamedType( /*@1.*/first_line, cast<Parse.Identifier>($1) );
             cast Parse.ParseTree($$).Comment = Parse.ParseTree.LastComment;
	}
|       base_type { cast Parse.ParseTree($$).Comment = Parse.ParseTree.LastComment; }
|	complex_type { cast Parse.ParseTree($$).Comment = Parse.ParseTree.LastComment; }
;


complex_type:
    type ARRAY_DEF
		{ $$ = new Parse.VectorType( /*@1.*/first_line, cast<Parse.TypeExpr>($1) ); }
|	type POINTER
		{ $$ = new Parse.PointerType( /*@1.*/first_line, cast<Parse.TypeExpr>($1) ); }
|	type REFERENCE
		{ $$ = new Parse.ReferenceType( /*@1.*/first_line, cast<Parse.TypeExpr>($1) ); }
|       type PROC OPEN_PAREN type_list CLOSE_PAREN
	        { $$ = new Parse.ProcType( first_line, cast Parse.TypeExpr($1), cast Parse.TypeExprList($4) ); }
|       type PROC OPEN_PAREN CLOSE_PAREN
	        { $$ = new Parse.ProcType( first_line, cast Parse.TypeExpr($1), null ); }
|       generic_type { $$ = $1; }

|       type OPEN_GENERIC CLOSE_GENERIC { $$ = $1; }
;

type_list:
	type { $$ = new Parse.TypeExprList(first_line); cast<Parse.TypeExprList>($$).add( cast<Parse.TypeExpr>($1) ); }
|
	type_list COMMA type { cast<Parse.TypeExprList>($1).add( cast<Parse.TypeExpr>($3) ); $$ = $1; }
;


base_type:
    INT
		{ $$ = new Parse.BaseType( /*@1.*/first_line, Type.INTEGER ); }
|   LONG       
                { $$ = new Parse.BaseType( /*@1.*/first_line, Type.LONG ); }
|   WORD	
                { $$ = new Parse.BaseType( /*@1.*/first_line, Type.WORD ); }
|   BOOL
		{ $$ = new Parse.BaseType( /*@1.*/first_line, Type.BOOL ); }
|   CHAR
		{ $$ = new Parse.BaseType( /*@1.*/first_line, Type.CHAR); }
|   BYTE
		{ $$ = new Parse.BaseType( /*@1.*/first_line, Type.BYTE); }
|   VOID
		{ $$ = new Parse.BaseType( /*@1.*/first_line, Type.VOID); }
;


%%


}